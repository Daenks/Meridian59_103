% Meridian 59, Copyright 1994-2012 Andrew Kirmse and Chris Kirmse.
% All rights reserved.
%
% This software is distributed under a license that is described in
% the LICENSE file that accompanies it.
%
% Meridian is a registered trademark.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
GameEvent is UtilityFunctions

constants:

   include blakston.khd

resources:

   include gameevent.lkod

   event_start_msg = "Event Started."
   event_end_msg = "Event Ended"

classvars:

   vrStartMessage = event_start_msg
   vrEndMessage = event_end_msg

   vbAnnounce = FALSE

properties:

   plSpawnRects = $
   poActiveRoom = $
   plEventRooms = $
   plRoomSaveState = $
   pbClearRooms = False

messages:

   Constructor()
   {
      return;
   }

   Delete()
   {
      plSpawnRects = $;
      poActiveRoom = $;
      plEventRooms = $;
      plRoomSaveState = $;
   
      return;
   }

   Update()
   {
      return;
   }

   NewMinute()
   {
      return;
   }

   NewHour()
   {
      return;
   }

   NewDay()
   {
      return;
   }

   NewMonth()
   {
      return;
   }

   NewYear()
   {
      return;
   }

   StartEvent()
   {
      if vbAnnounce
      {
         Send(SYS,@SystemBroadcast,#type=SAY_MESSAGE,#string=vrStartMessage);
      }

      return;
   }

   NotifyEngineEndEvent()
   {
      Send(Send(SYS,@GetEventEngine),@EventEnd,#parm1=self);

      return;
   }

   EndEvent()
   {
      if vbAnnounce
      {
         Send(SYS,@SystemBroadcast,#type=SAY_MESSAGE,#string=vrEndMessage);
      }

      return;
   }

   AdvanceEvent()
   {
      return;
   }
   
   PrepareRooms()
   {
      if pbClearRooms
      {
         Send(self,@ClearRooms);
      }
      
      return;
   }
   
   ClearRooms()
   {
      local i, j, lActive;
      
      lActive = $;
      
      if (pbClearRooms)
      {
         if (plEventRooms <> $)
         {
            for i in plEventRooms
            {
               lActive = Send(i,@GetPlActive);
               if (lActive <> $)
               {
                  for j in lActive
                  {
                     if ((IsClass(Nth(j,1),&Monster)) AND NOT (Send(Nth(j,1),@IsOwnedByPlayer)))
                     {
                        Send(Nth(j,1),@Delete);
                     }
                  }
               }
            }
         }
      }
   
      return;
   }
   
   SaveRoomStates()
   {
      local i, lRoomProps;

      for i in plEventRooms
      {
         lRoomProps = $;
         
         if IsClass(i,&MonsterRoom)
         {
            lRoomProps = AppendListElem(i,lRoomProps);
            lRoomProps = AppendListElem(Send(i,@CanMonsterGenerate),lRoomProps);
            lRoomProps = AppendListElem(Send(i,@GetGenerators),lRoomProps);
            lRoomProps = AppendListElem(Send(i,@GetGenTime),lRoomProps);
            lRoomProps = AppendListElem(Send(i,@GetGenPercent),lRoomProps);
            lRoomProps = AppendListElem(Send(i,@GetPatrolPaths),lRoomProps);
         }
         else
         {
            lRoomProps = [i,$,$,$,$];
         }
         plRoomSaveState = AppendListElem(lRoomProps,plRoomSaveState);
      }

      return;
   }
   
   RestoreRoomStates()
   {
      local i, oRoom;
      
      for i in plRoomSaveState
      {
         oRoom = Nth(i,1);
         
         if (IsClass(oRoom, &MonsterRoom))
         {
            Send(oRoom,@SetMonsterGeneration,#bValue=Nth(i,2));
            Send(oRoom,@SetGenerators,#generators=Nth(i,3));
            Send(oRoom,@SetGenTime,#time=Nth(i,4));
            Send(oRoom,@SetGenPercent,#percent=Nth(i,5));
            Send(oRoom,@SetPatrolPaths,#patrolPaths=Nth(i,6));
         }
      }
   
      return;
   }   

   CountMonsters(type=$)
   "Returns a count of the given type of monster."
   {
      local i, count, lActive;

      if type = $
      {
         return;
      }

      count = 0;
      lActive = Send(Send(SYS,@FindRoomByNum,#num=poActiveRoom),@GetPlActive);

      foreach i in lActive
      {
         if IsClass(Nth(i,1),type)
         {
            count = count + 1;
         }
      }

      return count;
   }

   MakeSpawnPoint()
   "Returns a spawn point inside a given rectangle."
   {
      local lCoords, spawnRect;

      spawnRect = Nth(plSpawnRects,Random(1,Length(plSpawnRects)));

      lCoords = [ Random(Nth(Nth(spawnRect,1),1),Nth(Nth(spawnRect,2),1)),
                  Random(Nth(Nth(spawnRect,1),2),Nth(Nth(spawnRect,2),2)) ];

      return lCoords;
   }

end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Meridian 59, Copyright 1994-2012 Andrew Kirmse and Chris Kirmse.
% All rights reserved.
%
% This software is distributed under a license that is described in
% the LICENSE file that accompanies it.
%
% Meridian is a registered trademark.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Weapon is PassiveItem

constants:

   include blakston.khd
   
   USED = 1
   UNUSED = 2
   ATTACKING = 3

   WEAPON_DAMAGE_CHANCE = 25

   % Weapon tuning factors
   % Edit these constants to tune weapon power

   % Hit modifiers
   WEAPON_HITMOD_STRIKE  = 0
   WEAPON_HITMOD_THRUST  = 0
   WEAPON_HITMOD_SLASH = 0
   WEAPON_HITMOD_SPELL = 0
   WEAPON_HITMOD_FIST = 0

   % Base damage of different types
   WEAPON_DAMAGE_STRIKE  = 8
   WEAPON_DAMAGE_THRUST  = 8
   WEAPON_DAMAGE_SLASH = 8
   WEAPON_DAMAGE_SPELL = 8
   WEAPON_DAMAGE_FIST = 8

   % Proficiency bonus
   WEAPON_PROF_STRIKE  = 0
   WEAPON_PROF_THRUST  = 0
   WEAPON_PROF_SLASH = 0
   WEAPON_PROF_SPELL = 0
   WEAPON_PROF_FIST = 0
	
   % Disarm bonus
   WEAPON_DISARM_STRIKE  = 0
   WEAPON_DISARM_THRUST  = 0
   WEAPON_DISARM_SLASH = 50
   WEAPON_DISARM_SPELL = 0
   WEAPON_DISARM_FIST = 0
   
   % Parry bonus
   WEAPON_PARRY_STRIKE  = 0
   WEAPON_PARRY_THRUST  = 50
   WEAPON_PARRY_SLASH = 0
   WEAPON_PARRY_SPELL = -100
   WEAPON_PARRY_FIST = 0

   % Spell modifier, large negatives are bad.
   WEAPON_SPELL_STRIKE  = 20
   WEAPON_SPELL_THRUST  = -20
   WEAPON_SPELL_SLASH = -20
   WEAPON_SPELL_SPELL = -20
   WEAPON_SPELL_FIST = -20

   % Range of reach
   WEAPON_RANGE_STRIKE  = 2
   WEAPON_RANGE_THRUST  = 2
   WEAPON_RANGE_SLASH = 2
   WEAPON_RANGE_SPELL = 2
   WEAPON_RANGE_FIST = 2

   % Quality mods to number of hits
   WEAPON_NORMAL_QUALITY_HITS  = 0
   WEAPON_HIGH_QUALITY_HITS  = 100
	WEAPON_SUPREME_QUALITY_HITS = 200
   WEAPON_NERUDITE_HITS = 200

   % Quality mods to hit modifier
   WEAPON_NORMAL_QUALITY_HITMOD  = 0
   WEAPON_HIGH_QUALITY_HITMOD  = 0
   WEAPON_SUPREME_QUALITY_HITMOD = 0
   WEAPON_NERUDITE_HITMOD = 0

   % Quality mods to damage
   WEAPON_NORMAL_QUALITY_DAMAGE  = 0
   WEAPON_HIGH_QUALITY_DAMAGE  = 0
   WEAPON_SUPREME_QUALITY_DAMAGE = 0
   WEAPON_NERUDITE_DAMAGE = 0
   
   % Quality mods to proficiency
   WEAPON_NORMAL_QUALITY_PROF  = 0
   WEAPON_HIGH_QUALITY_PROF = 50
   WEAPON_SUPREME_QUALITY_PROF = 100
   WEAPON_NERUDITE_PROF = 100

   % Quality mods to disarming
   WEAPON_NORMAL_QUALITY_DISARM  = 0
   WEAPON_HIGH_QUALITY_DISARM  = 50
   WEAPON_SUPREME_QUALITY_DISARM = 100
   WEAPON_NERUDITE_DISARM = 100

   % Quality mods to parrying
   WEAPON_NORMAL_QUALITY_PARRY  = 0
   WEAPON_HIGH_QUALITY_PARRY  = 50
   WEAPON_SUPREME_QUALITY_PARRY = 100
   WEAPON_NERUDITE_PARRY = 100

   % Quality mods to spell modifier
   WEAPON_NORMAL_QUALITY_SPELL  = 0
   WEAPON_HIGH_QUALITY_SPELL  = -10
   WEAPON_SUPREME_QUALITY_SPELL = -20
   WEAPON_NERUDITE_SPELL =  -20

   % Quality mod to range
   WEAPON_NORMAL_QUALITY_RANGE  = 0
   WEAPON_HIGH_QUALITY_RANGE = 0
   WEAPON_SUPREME_QUALITY_RANGE = 1
   WEAPON_NERUDITE_RANGE = 1

resources:

   weapon_already_broken = "%s%s is broken; you can't use it!"
   weapon_broken = "%s%s shatters into pieces."

   weapon_condition_exc = " is in flawless condition."
   weapon_condition_exc_mended = " is in excellent condition, but has been repaired before."
   weapon_condition_good = " is slightly tarnished but in generally good condition."
   weapon_condition_med = " is notched and stained with blood but is still an effective weapon."
   weapon_condition_poor = " is well worn and may not last much longer."
   weapon_condition_broken = " has been shattered by a powerful blow."

   % These are used by weapon enchantments to tell where some symbol
   %  happens to be on the blade.
   weapon_head = "on the head"
   weapon_grip = "on the grip"
	
	extended_description = ""

classvars:

   viUse_type = ITEM_USE_MAIN_HAND
   viItem_Type = ITEMTYPE_WEAPON
   viUse_amount = 1

   vrPoss_article_rsc = object_article_cap_this_rsc

   %if not nil, the weapon will check for ammo in the ITEM_USE_QUIVER slot
   %added to player.kod and remove one--ammo is a numbered item
   vcAmmo = $

   vrWeapon_window_overlay = $
   vrWeapon_window_attack_start = 1
   vrWeapon_window_attack_end = 4
   vrWeapon_window_hold = 5

   vrWeapon_overlay = $

   % if it's set to a number, it's always used
   viBroken_group = $
   
   % Message when the weapon breaks.
   vrItem_broken = weapon_broken
   
   viWeaponType = WEAPON_TYPE_THRUST
   viWeaponQuality = WEAPON_QUALITY_HIGH

   viProficiency_needed = SKID_PROFICIENCY_SWORD

   viHits_init_min = 250
   viHits_init_max = 300

   vbShow_condition = TRUE
   vrCondition_exc = weapon_condition_exc 
   vrCondition_exc_mended = weapon_condition_exc_mended 
   vrCondition_good = weapon_condition_good 
   vrCondition_med = weapon_condition_med 
   vrCondition_poor = weapon_condition_poor 
   vrCondition_broken = weapon_condition_broken
	
	vrExtendedDescription = extended_description
   
   viParry_chance = 0
	viProf_bonus = 0
	
   % Weapons fight for a spot with instruments.
	viLayer = 1

properties:

   piAttack_type = 0
   piAttack_spell = 0
   
   piDamageBonus = 0
   piHitBonus = 0

   piUsed = UNUSED

messages:

   Constructed()
   {
      % Modify the hits depending on the weapon's quality.
      if viWeaponQuality = WEAPON_QUALITY_NORMAL
      {
         piHits_init = piHits_init + WEAPON_NORMAL_QUALITY_HITS;
         piHits = piHits + WEAPON_NORMAL_QUALITY_HITS;
      }
      if viWeaponQuality = WEAPON_QUALITY_HIGH
      {
         piHits_init = piHits_init + WEAPON_HIGH_QUALITY_HITS;
         piHits = piHits + WEAPON_HIGH_QUALITY_HITS;
      }
      if viWeaponQuality = WEAPON_QUALITY_SUPREME
      {
         piHits_init = piHits_init + WEAPON_SUPREME_QUALITY_HITS;
         piHits = piHits + WEAPON_SUPREME_QUALITY_HITS;
      }
      if viWeaponQuality = WEAPON_NERUDITE
      {
         piHits_init = piHits_init + WEAPON_NERUDITE_HITS;
         piHits = piHits + WEAPON_NERUDITE_HITS;
      }

      propagate;
   }
	
   AppendDesc()
   {
      AppendTempString("\n\n");
      AppendTempString(vrExtendedDescription);
      propagate;
   }
   
   DoRiposte(who=$,what=$)
   {
      local oStroke;
	  
	   oStroke = Send(sys,@FindSkillByNum,#num=SKID_RIPOSTE);
	   % This will trigger a free regular weapon attack on a successful parry.	  
	   % Using TryAttack instead of DoExtraAttack since we want to factor in chance to hit.
      Send(who,@TryAttack,#what=what,#stroke_obj=oStroke,#use_weapon=self,#activeuser=FALSE);
	
	  return;
   }

   %%% Hard Stats Functions
   %%% (Range, hit chance, damage, etc)

   % An explanation of how weapons work now:
   % Weapons can now be described as a combination of two different aspects, type and quality.
   % The three types of weapons are thrusting (swords), bludgeoning, and slashing (heavy weapons).
   %  These three types of weapons have attributes as follows:

   % Type      Hit Mod     Damage     Disarm     Spell    Range
   % ----------------------------------------------------------
   % Strike     0           0          0          10       2
   % Thrust     0           0          0          0        3
   % Slash      200         2          5          0        2

   % These aspects are defined with the appropriate constants in Blakston.khd
   % In general, High is desirable and Low is not.  So, a thrusting weapons hits
   % more often than a slashing one does, but it does less damage, etc.
   %
   % Weapons can also have quality.  Current, the four types of quality are high, low,
   % normal and nerudite.  These also have constants defined.  In general, the lower the
   % quality, the worse it makes the weapon.  The exception is spell bonus; higher quality
   % weapons actually give less bonus than lower quality weapons
   %
   % Nerudite isn't really comparable to the other qualities, but this was the best way to
   % describe the weapon.
   %
   % So, now, all you should really do is define the type of weapons and its relative
   % quality.  Weapon will handle the rest.

   ModifyHitRoll(hit_roll = 0, target = $)
   "When someone attacks with this weapon, they send us their attack value "
   "and we change it based on quality of weapon"
   {
      local iBonus;

      iBonus = 0;

      % Weapon type
      if viWeaponType = WEAPON_TYPE_STRIKE
      {
         iBonus = WEAPON_HITMOD_STRIKE;
      }

      if viWeaponType = WEAPON_TYPE_THRUST
      {
         iBonus = WEAPON_HITMOD_THRUST;
      }

      if viWeaponType = WEAPON_TYPE_SLASH
      {
         iBonus = WEAPON_HITMOD_SLASH;
      }

      if viWeaponType = WEAPON_TYPE_SPELL
      {
         iBonus = WEAPON_HITMOD_SPELL;
      }
		
      if viWeaponType = WEAPON_TYPE_FIST
      {
         iBonus = WEAPON_HITMOD_FIST;
      }

      % Weapon quality modifiers
      if viWeaponQuality = WEAPON_QUALITY_NORMAL
      {
         iBonus = iBonus + WEAPON_NORMAL_QUALITY_HITMOD;
      }
		
      if viWeaponQuality = WEAPON_QUALITY_HIGH
      {
         iBonus = iBonus + WEAPON_HIGH_QUALITY_HITMOD;
      }

      if viWeaponQuality = WEAPON_QUALITY_SUPREME
      {
         iBonus = iBonus + WEAPON_SUPREME_QUALITY_HITMOD;
      }

      if viWeaponQuality = WEAPON_NERUDITE
      {
         iBonus = iBonus + WEAPON_NERUDITE_HITMOD;
      }

      iBonus = iBonus + piHitBonus;

      return iBonus;
   }

   GetBaseDamage(who=$,target=$)
   {
      local iDamage;
      
      % Weapon type
      if viWeaponType = WEAPON_TYPE_STRIKE
      {
         iDamage = WEAPON_DAMAGE_STRIKE;
      }

      if viWeaponType = WEAPON_TYPE_THRUST
      {
         iDamage = WEAPON_DAMAGE_THRUST;
      }

      if viWeaponType = WEAPON_TYPE_SLASH
      {
         iDamage = WEAPON_DAMAGE_SLASH;
      }
		
      if viWeaponType = WEAPON_TYPE_SPELL
      {
         iDamage = WEAPON_DAMAGE_SPELL;
      }
		
      if viWeaponType = WEAPON_TYPE_FIST
      {
         iDamage = WEAPON_DAMAGE_FIST;
      }

      % Weapon quality modifiers
      if viWeaponQuality = WEAPON_QUALITY_NORMAL
      {
         iDamage = iDamage + WEAPON_NORMAL_QUALITY_DAMAGE;
      }

      % Weapon quality modifiers
      if viWeaponQuality = WEAPON_QUALITY_HIGH
      {
         iDamage = iDamage + WEAPON_HIGH_QUALITY_DAMAGE;
      }
		
      if viWeaponQuality = WEAPON_QUALITY_SUPREME
      {
         iDamage = iDamage + WEAPON_SUPREME_QUALITY_DAMAGE;
      }

      if viWeaponQuality = WEAPON_NERUDITE
      {
         iDamage = iDamage + WEAPON_NERUDITE_DAMAGE;
      }

      return iDamage;
   }
   
   GetDamage(target=$)
   {
      local iDamage;

      % First, get base damage.
      iDamage = send(self,@GetBaseDamage,#who=poOwner,#target=target);

      iDamage = iDamage + piDamageBonus;
  
      iDamage = iDamage * 100;

      return iDamage;
   }

   GetRange()
   {
      local iRange;
      
      % Weapon type
      if viWeaponType = WEAPON_TYPE_STRIKE
      {
         iRange = WEAPON_RANGE_STRIKE;
      }

      if viWeaponType = WEAPON_TYPE_THRUST
      {
         iRange = WEAPON_RANGE_THRUST;
      }

      if viWeaponType = WEAPON_TYPE_SLASH
      {
         iRange = WEAPON_RANGE_SLASH;
      }
		
      if viWeaponType = WEAPON_TYPE_SPELL
      {
         iRange = WEAPON_RANGE_SPELL;
      }
		
      if viWeaponType = WEAPON_TYPE_FIST
      {
         iRange = WEAPON_RANGE_FIST;
      }

      % Weapon quality modifiers
      if viWeaponQuality = WEAPON_QUALITY_NORMAL
      {
         iRange = iRange + WEAPON_NORMAL_QUALITY_RANGE;
      }

      if viWeaponQuality = WEAPON_QUALITY_HIGH
      {
         iRange = iRange + WEAPON_HIGH_QUALITY_RANGE;
      }

      if viWeaponQuality = WEAPON_QUALITY_SUPREME
      {
         iRange = iRange + WEAPON_SUPREME_QUALITY_RANGE;
      }

      if viWeaponQuality = WEAPON_NERUDITE
      {
         iRange = iRange + WEAPON_NERUDITE_RANGE;
      }

      return iRange;
   }   

   GetDisarmBonus()
   "Weapon's bonus to disarm attempts, roughly in percent"
   {
      local iDisarm;
      
      % Weapon type
      if viWeaponType = WEAPON_TYPE_STRIKE
      {
         iDisarm = WEAPON_DISARM_STRIKE;
      }

      if viWeaponType = WEAPON_TYPE_THRUST
      {
         iDisarm = WEAPON_DISARM_THRUST;
      }

      if viWeaponType = WEAPON_TYPE_SLASH
      {
         iDisarm = WEAPON_DISARM_SLASH;
      }
		
      if viWeaponType = WEAPON_TYPE_SPELL
      {
         iDisarm = WEAPON_DISARM_SPELL;
      }
		
      if viWeaponType = WEAPON_TYPE_FIST
      {
         iDisarm = WEAPON_DISARM_FIST;
      }

      % Weapon quality modifiers
      if viWeaponQuality = WEAPON_QUALITY_NORMAL
      {
         iDisarm = iDisarm + WEAPON_NORMAL_QUALITY_DISARM;
      }
		
      if viWeaponQuality = WEAPON_QUALITY_HIGH
      {
         iDisarm = iDisarm + WEAPON_HIGH_QUALITY_DISARM;
      }

      if viWeaponQuality = WEAPON_QUALITY_SUPREME
      {
         iDisarm = iDisarm + WEAPON_SUPREME_QUALITY_DISARM;
      }

      if viWeaponQuality = WEAPON_NERUDITE
      {
         iDisarm = iDisarm + WEAPON_NERUDITE_DISARM;
      }

      return iDisarm;
   }
   
   % Return parry ability, include bonuses.
   GetParryAbility(who=$)
   {
      local iParry;
      
      % Weapon type
      if viWeaponType = WEAPON_TYPE_STRIKE
      {
         iParry = WEAPON_PARRY_STRIKE;
      }

      if viWeaponType = WEAPON_TYPE_THRUST
      {
         iParry = WEAPON_PARRY_THRUST;
      }

      if viWeaponType = WEAPON_TYPE_SLASH
      {
         iParry = WEAPON_PARRY_SLASH;
      }

      if viWeaponType = WEAPON_TYPE_SPELL
      {
         iParry = WEAPON_PARRY_SPELL;
      }
		
      if viWeaponType = WEAPON_TYPE_FIST
      {
         iParry = WEAPON_PARRY_FIST;
      }
		
      % Weapon quality modifiers
      if viWeaponQuality = WEAPON_QUALITY_NORMAL
      {
         iParry = iParry + WEAPON_NORMAL_QUALITY_PARRY;
      }
		
      if viWeaponQuality = WEAPON_QUALITY_HIGH
      {
         iParry = iParry + WEAPON_HIGH_QUALITY_PARRY;
      }

      if viWeaponQuality = WEAPON_QUALITY_SUPREME
      {
         iParry = iParry + WEAPON_SUPREME_QUALITY_PARRY;
      }

      if viWeaponQuality = WEAPON_NERUDITE
      {
         iParry = iParry + WEAPON_NERUDITE_PARRY;
      }
	  
      return send(who,@GetAbility,#num=SKID_PARRY) * (100 + viParry_chance) / 100;
   }

   GetBaseSpellModifier()
   {
      local iModifier;

      % Weapon type
      if viWeaponType = WEAPON_TYPE_STRIKE
      {
         iModifier = WEAPON_SPELL_STRIKE;
      }

      if viWeaponType = WEAPON_TYPE_THRUST
      {
         iModifier = WEAPON_SPELL_THRUST;
      }

      if viWeaponType = WEAPON_TYPE_SLASH
      {
         iModifier = WEAPON_SPELL_SLASH;
      }

      if viWeaponType = WEAPON_TYPE_SPELL
      {
         iModifier = WEAPON_SPELL_SPELL;
      }
		
      if viWeaponType = WEAPON_TYPE_FIST
      {
         iModifier = WEAPON_SPELL_FIST;
      }
		
      % Weapon quality modifiers
      if viWeaponQuality = WEAPON_QUALITY_NORMAL
      {
         iModifier = iModifier + WEAPON_NORMAL_QUALITY_SPELL;
      }

      if viWeaponQuality = WEAPON_QUALITY_HIGH
      {
         iModifier = iModifier + WEAPON_HIGH_QUALITY_SPELL;
      }
		
      if viWeaponQuality = WEAPON_QUALITY_SUPREME
      {
         iModifier = iModifier + WEAPON_SUPREME_QUALITY_SPELL;
      }

      if viWeaponQuality = WEAPON_NERUDITE
      {
         iModifier = iModifier + WEAPON_NERUDITE_SPELL;
      }

      return iModifier;
   }

   %%%  Advancement functions (strokes and proficiencies)  

   GetProf(who=$)
   {
		local iProf, iBonus;   
		
		iBonus = viProf_bonus;

      % Weapon type
      if viWeaponType = WEAPON_TYPE_STRIKE
      {
         iBonus = iBonus + WEAPON_PROF_STRIKE;
      }

      if viWeaponType = WEAPON_TYPE_THRUST
      {
         iBonus = iBonus + WEAPON_PROF_THRUST;
      }

      if viWeaponType = WEAPON_TYPE_SLASH
      {
         iBonus = iBonus + WEAPON_PROF_SLASH;
      }
		
      if viWeaponType = WEAPON_TYPE_SPELL
      {
         iBonus = iBonus + WEAPON_PROF_SPELL;
      }
		
      if viWeaponType = WEAPON_TYPE_FIST
      {
         iBonus = iBonus + WEAPON_PROF_FIST;
      }

      % Weapon quality modifiers
      if viWeaponQuality = WEAPON_QUALITY_NORMAL
      {
         iBonus = iBonus + WEAPON_NORMAL_QUALITY_PROF;
      }
		
      if viWeaponQuality = WEAPON_QUALITY_HIGH
      {
         iBonus = iBonus + WEAPON_HIGH_QUALITY_PROF;
      }

      if viWeaponQuality = WEAPON_QUALITY_SUPREME
      {
         iBonus = iBonus + WEAPON_SUPREME_QUALITY_PROF;
      }

      if viWeaponQuality = WEAPON_NERUDITE
      {
         iBonus = iBonus + WEAPON_NERUDITE_PROF;
      }

		iProf = send(who,@GetAbility,#num=send(self,@GetProfNumber)) * (100 + iBonus) / 100;
		
      return iProf;
   }

   GetProfNumber()
   {
      return viProficiency_needed;
   }

   GetStroke(who=$)
   {
      return send(who,@GetAbility,#num=Send(self,@GetStrokeNumber));
   }

   GetStrokeNumber()
   {
      return SKID_SLASH;
   }

   ImproveProficiency(who=$,target=$)
   {      
      send(send(SYS,@findSkillbynum,#num=viProficiency_needed),@ImproveAbility,#who=who,#target=target);
             
      return;
   }

   % What is the weapon's name for use in the attack messages?
   GetAttackName()
   {
      return vrName;
   }

   %%%  Infrastructure

   DamageGear(who = $,what = $)
   {
      % 25% chance to get damaged.
      if (random(1,100) < WEAPON_DAMAGE_CHANCE)
      {
         propagate;
      }
      
      return;
   }

   ReqWeaponAttack(what = $)
   {
      if piHits <= 0
      {
         Send(poOwner,@MsgSendUser,#message_rsc=weapon_already_broken,
              #parm1=Send(self,@GetCapDef),#parm2=vrName);
         Send(poOwner,@TryUnuseItem,#what=self);
         
         return FALSE;
      }

      Send(self,@WeaponAttack,#what=what);
      
      return TRUE;
   }

   ReqUseAmmo(ammotype = $)
   "At this point, a non-ranged weapon SHOULD never make it this far "
   "(see ReqWeaponAttack above).  This is just to catch anything that "
   "slips thru the cracks.  See ranged.kod for what this does."
   {
      debug("A non-ranged weapon called @ReqUseAmmo!");
      
      return TRUE;
   }

   WeaponAttack(what = $)
   "Called by ReqWeaponAttack when the weapon is actually used in an attack."
   {
      piUsed = ATTACKING;
      
      if vrWeapon_window_overlay <> $
      {
         Send(poOwner,@ChangeWindowOverlay,#what=self);
      }
      
      if vrWeapon_overlay <> $
      {
         Send(poOwner,@DoAttackSwing);
      }
      
      piUsed = USED;

      return;
   }

   DoParryAnimation()
   {
      piUsed = ATTACKING;
      
      if vrWeapon_window_overlay <> $
      {
         Send(poOwner,@ChangeWindowOverlay,#what=self);
      }
      
      if vrWeapon_overlay <> $
      {
         Send(poOwner,@DoAttackSwing);
      }
      
      piUsed = USED;

      return;
   }

   NewUsed()
   {
      local oItemAtt;

      % This alerts Item attributes when item is used.
      % Currently special checks for "glowing" weapon attribute.
      if send(self,@HasAttribute,#ItemAtt=WA_GLOWING)
      {
         oItemAtt = send(SYS,@FindItemAttByNum,#num=WA_GLOWING);
         send(oItemAtt,@ItemUsed,#oItem=self,#oPlayer=poOwner);
      }

      piUsed = USED;

      % do first person overlay if we have one
      if vrWeapon_window_overlay <> $
      {
         Send(poOwner,@SetWindowOverlay,#what=self);
      }

      % do third person overlay if we have one
      if vrWeapon_overlay <> $
      {
         Send(poOwner,@SetOverlay,#what=self);
      }

      propagate;
   }

   NewUnused()
   {
      local oItemAtt;

      % This alerts Item attributes when item is used.
      % Currently special checks for "glowing" weapon attribute.
      if send(self,@HasAttribute,#ItemAtt=WA_GLOWING)
      {
         oItemAtt = send(SYS,@FindItemAttByNum,#num=WA_GLOWING);
         send(oItemAtt,@ItemUnused,#oItem=self,#oPlayer=poOwner);
      }

      piUsed = UNUSED;

      if vrWeapon_window_overlay <> $
      {
         Send(poOwner,@RemoveWindowOverlay,#what=self);
      }

      if vrWeapon_overlay <> $
      {
         Send(poOwner,@RemoveOverlay,#what=self);
      }

      propagate;
   }


   %%% Attack Type Functions (Enchanted weapons, Qor weapons, burning blades, etc.)
   

   GetAttackSpell()
   {
      return piAttack_spell;
   }

   GetAttackType()
   {
      return piAttack_type;
   }

   SetTypeFlag(flag=0, value=FALSE)
   {
      if value
      {
         piAttack_type = piAttack_type | flag ;
      }
      else
      {
         piAttack_type = piAttack_type & ~flag ;
      }
      
      return;
   }

   CheckTypeFlag(flag=0)
   {
      return (piAttack_type & flag) ;
   }

   SetSpellFlag(flag=0, value=FALSE)
   {
      if value
      {
         piAttack_spell = piAttack_spell | flag ;
      }
      else
      {
         piAttack_spell = piAttack_spell & ~flag ;
      }
      
      return;
   }

   CheckSpellFlag(flag = 0)
   {
      return (piAttack_spell & flag);
   }

   %%% Animation Functions

   % these 5 called by player, for window overlays.
   % weapon subclasses--do NOT set a window overlay unless you either
   % set vrWeapon_window_overlay correctly or override all these message handlers
   GetWindowOverlay()
   {
      return vrWeapon_window_overlay;
   }

   GetWindowOverlayID()
   {
      return PWO_RIGHT_HAND;
   }

   GetWindowOverlayHotspot()
   {
      if piUsed = UNUSED
      {
         % turns off the window overlay
         return 0;
      }

      return HS_SE;
   }

   SendWindowOverlayAnimation()
   {
      local iFlags;

      iFlags = piItem_flags & ITEM_PALETTE_MASK;
      if iFlags <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION, 1,iFlags);
      }
      
      if piUsed = ATTACKING
      { 
         AddPacket(1,ANIMATE_ONCE, 4,150, 2,vrWeapon_window_attack_start,
                   2,vrWeapon_window_attack_end, 2,vrWeapon_window_hold);
      }
      else
      {
         AddPacket(1,ANIMATE_NONE, 2,vrWeapon_window_hold);
      }
      
      return;      
   }

   SendWindowOverlayOverlays()
   {
      % no overlays
      AddPacket(1,0); 

      return; 
   }

   % These 3 called by player, for normal 3rd-person overlays on user.
   %  weapon subclasses--do NOT set a window overlay unless you either
   %  set vrWeapon_overlay correctly or override all these message handlers

   GetOverlay(animation = $)
   {
      return vrWeapon_overlay;
   }
   
   GetOverlayHotspot(animation = $)
   {
      return HS_RIGHT_WEAPON;
   }

   SendOverlayAnimation(iAnimation = $)
   {
      local iFlags;

      iFlags = piItem_flags & ITEM_PALETTE_MASK;
      if iFlags <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION, 1,iFlags);
      }
      
      if iAnimation = PANM_WEAPON_ATTACK 
      {
         AddPacket(1,ANIMATE_ONCE, 4,300, 2,1, 2,3, 2,4);
      }
      else
      { 
         AddPacket(1,ANIMATE_NONE, 2,4);
      }
      
      return;
   }

   SendOverlayInformation(ianimation = $)
   {
      AddPacket(4,Send(self,@GetOverlay));
      AddPacket(1,Send(self,@GetOverlayHotspot));
      Send(self,@SendOverlayAnimation,#iAnimation=iAnimation);
      
      return;
   }

   SendInventoryAnimation()
   {
      local iFlags;

      if piHits > 0 OR viBroken_group = $
      {
         propagate;
      }

      iFlags = piItem_flags & ITEM_PALETTE_MASK;
      if iFlags <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION, 1,iFlags);
      }

      AddPacket(1,ANIMATE_NONE, 2,viBroken_group);
      
      return;
   }

   SendLookAnimation()
   {
      local iFlags;

      if piHits > 0 OR viBroken_group = $
      {
         propagate;
      }

      if (piItem_flags & ITEM_PALETTE_MASK) <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION,1,piItem_flags & ITEM_PALETTE_MASK);
      }

      AddPacket(1,ANIMATE_NONE,2,viBroken_group);
      
      return;
   }

   SendAnimation()
   {
      local iFlags;

      if piHits > 0 OR viBroken_group = $
      {
         propagate;
      }

      iFlags = piItem_flags & ITEM_PALETTE_MASK;
      if iFlags <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION, 1,iFlags);
      }

      AddPacket(1,ANIMATE_NONE, 2,viBroken_group);

      return;
   }

   %%% Permission Functions

   CanMend()
   "Weapons are mendable, usually."
   { 
      local i, oItemAtt;
      
      for i in plItem_Attributes
      {
         oItemAtt = send(SYS,@FindItemAttByNum,
                         #num=send(self,@GetNumFromCompound,#compound=first(i)));
         if oItemAtt = $
         {
            DEBUG("Illegal ItemAtt in list!");

            continue;
         }
    
         if NOT send(oItemAtt,@ItemCanMend,#oItem=self)
         {
            return FALSE;
         }
      }

      return TRUE; 
   }

   CanEnchant(oSpell = $)
   "Weapons CAN usually be dedicated to Qor, Kraanan or Shal'ille.  "
   "Exception:  weapons that are already enchanted may not be, "
   "but this is taken care of on a spell by spell basis, so that reagents "
   "are used correctly."
   {
      local i, oItemAtt, iSpell;

      if piAttack_spell <> 0      
         OR send(self,@CheckTypeFlag,#flag=ATCK_WEAP_MAGIC)
      { 
         iSpell = send(oSpell,@GetSpellNum);
         if iSpell = SID_HOLY_WEAPON or iSpell = SID_UNHOLY_WEAPON 
            OR iSpell = SID_ENCHANT_WEAPON
         {
            return FALSE;
         }
      }   

      for i in plItem_Attributes
      {
         oItemAtt = send(SYS,@FindItemAttByNum,
                         #num=send(self,@GetNumFromCompound,#compound=first(i)));
         if oItemAtt = $
         {
            DEBUG("Illegal ItemAtt in list!");

            continue;
         }

         if NOT send(oItemAtt,@ItemCanEnchant,#oItem=self)
         {
            return FALSE;
         }
      }

      return TRUE;
   }

   ReqRepair()
   {
      return TRUE;
   }

end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

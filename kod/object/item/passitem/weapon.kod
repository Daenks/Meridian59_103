% Meridian 59, Copyright 1994-2012 Andrew Kirmse and Chris Kirmse.
% All rights reserved.
%
% This software is distributed under a license that is described in
% the LICENSE file that accompanies it.
%
% Meridian is a registered trademark.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Weapon is PassiveItem

constants:

   include blakston.khd

   USED = 1
   UNUSED = 2
   ATTACKING = 3

   WEAPON_TAKE_DAMAGE_PCT = 75

resources:

   weapon_already_broken = "%s%s is broken; you can't use it!"
   weapon_broken = "%s%s shatters into pieces."

   weapon_condition_exc = " is in flawless condition."
   weapon_condition_exc_mended = " is in excellent condition, but has been repaired before."
   weapon_condition_good = " is slightly tarnished but in generally good condition."
   weapon_condition_med = " is notched and stained with blood but is still an effective weapon."
   weapon_condition_poor = " is well worn and may not last much longer."
   weapon_condition_broken = " has been shattered by a powerful blow."

   weapon_do_damage = "I just did %i points of damage! (%i)"
   weapon_to_hit = "I have a %i chance to hit! (%i/%i)"

   % These are used by weapon enchantments to tell where some symbol
   %  happens to be on the blade.
   weapon_head = "on the head"
   weapon_grip = "on the grip"

classvars:

   viUse_type = ITEM_USE_HAND
   viItem_Type = ITEMTYPE_WEAPON
   viUse_amount = 1

   vrPoss_article_rsc = object_article_cap_this_rsc

   %if not nil, the weapon will check for ammo in the ITEM_USE_QUIVER slot
   %added to player.kod and remove one--ammo is a numbered item
   vcAmmo = $

   vrWeapon_window_overlay = $
   vrWeapon_window_attack_start = 1
   vrWeapon_window_attack_end = 4
   vrWeapon_window_hold = 5

   vrWeapon_overlay = $

   % if it's set to a number, it's always used
   viBroken_group = $
   % Message when the weapon breaks.
   vrWeaponBroke = weapon_broken
   
   viProficiency_needed = SKID_PROFICIENCY_SWORD

   viHits_init_min = 500
   viHits_init_max = 500

   vbShow_condition = TRUE
   vrCondition_exc = weapon_condition_exc 
   vrCondition_exc_mended = weapon_condition_exc_mended 
   vrCondition_good = weapon_condition_good 
   vrCondition_med = weapon_condition_med 
   vrCondition_poor = weapon_condition_poor 
   vrCondition_broken = weapon_condition_broken
   
properties:

   piRange = 3

   % Damage values are using high precision.
   piMinDamage = 500
   piMaxDamage = 1000
   piProficiencyBonus = 500
   piHitMod = 0
   piSpellpowerMod = 0

   piDisarmMod = 0
   piParryMod = 0
   
   piStab = 100
   piStrike = 100
   piSlash = 100
   piThrust = 100
   piFire = 100
   piTouch = 100

   % The stats relevant for this weapon. Primary stat scales damage while
   % secondary stat scales a bonus effect that varies with weapon class.
   piPrimaryStat = STAT_MIGHT
   piSecondaryStat = STAT_MIGHT

   % The percentage of effect that primary and secondary stats add at 50.
   piPrimaryScaling = 100
   piSecondaryScaling = 100

   piQuality = 100

   piAttack_type = 0
   piAttack_spell = 0

   piUsed = UNUSED

messages:

   % This creates our weapon based on a list of stats and types. If no list of
   % stats is provided, we randomize the process of creation instead.
   % This is a listing of the entires of both lstats and ltypes:
   % ltypes
   % 1) piPrimaryStat
   % 2) piSecondaryStat  
   % 3) piAttack_type
   % 4) piAttack_spell
   % 5) piRange
   % lstats
   % 1) piMinDamage = First(lstats);
   % 2) piMaxDamage = Nth(lstats,2);
   % 3) piProficiencyBonus = Nth(lstats,3);
   % 4) piHitMod = Nth(lstats,4);
   % 5) piSpellpowerMod = Nth(lstats,5);
   % 6) piPrimaryScaling = Nth(lstats,16);
   % 7) piSecondaryScaling = Nth(lstats,17);
   % 8) piDisarmMod = Nth(lstats,6);
   % 9) piParryMod = Nth(lstats,7);
   % 10) piStab = Nth(lstats,8);
   % 11) piStrike = Nth(lstats,9);
   % 12) piSlash = Nth(lstats,10);
   % 13) piThrust = Nth(lstats,11);
   % 14) piFire = Nth(lstats,12);
   % 15) piTouch = Nth(lstats,13);
   Constructor(lstats=$,ltypes=$)
   {
      local = list, i, n, iDeviation, iQuality;

      % Create a temporary list to easily handle stats creation.
      list =[piMinDamage,piMaxDamage,piProficiencyBonus,piHitMod,piSpellpowerMod,
         piPrimaryScaling,piSecondaryScaling,piDisarmMod,piParryMod,
         piStab,piStrike,piSlash,piThrust,piFire,piTouch]

      iQuality = 0;
      n = 0;
         
      if lstats <> $
      {
         for i in list
         {
            if Nth(list,i) <> 0
            {
               iDeviation = 100*Nth(lstats,i)/Nth(list,i) - 100;
               n = n +1;
            }
            
            Setnth(list,i,Nth(lstats,i));

            % We sum up the percentual deviation the set stats have from the
            % base stats and divide by the number of deviating properties to
            % determine the item's quality.
            iQuality = iQuality + iDeviation;
         }

         if n <> 0
         {
            iQuality = 100 + (iQuality / n);
         }
         else
         {
            iQuality = 100;
         }
      }
      else
      {
         for i in list
         {
            iDeviation = random(-40,20);
            
            Setnth(list,i,Nth(list,i)*(100+iDeviation));

            iQuality = iQuality + iDeviation;
            
            n = n +1;
         }
         
         if n <> 0
         {
            iQuality = 100 + (iQuality / n);
         }
         else
         {
            iQuality = 100;
         }
      }

      % Time to set item's quality.
      piQuality = iQuality;

      % Create a temporary list to easily handle type creation.
      list =[piPrimaryStat,piSecondaryStat,piAttack_type,piAttack_spell,piRange]

      if ltypes <> $
      {
         for i in list
         {
            Setnth(list,i,Nth(lstats,i));
         }
      }

      % If we don't set types, take default types.
      
      propagate;
   }
   
   Constructed()
   {
      % Scale durability with the quality factor.
      piHits_init = piHits_init * piQuality / 100;
      piHits = piHits * piQuality / 100;

      propagate;
   }

   AppendDesc()
   {
      local i, target_type;

      if plObject_attributes <> $
      {
         for i in plObject_attributes
         {
            if IsClass(i,&WeaponSpellProc)
            {
               AppendTempString("\n\n");
               AppendTempString("Upon a successful strike, the runes engraved on this "); 
               AppendTempString(Send(self,@GetName));
               AppendTempString(" will cast ");
               AppendTempString(Send(Send(i,@GetSpell),@GetName));
               AppendTempString(" ");

               target_type = Send(i,@GetType);
               if target_type = 1
               {
                  AppendTempString("on you ");
               }
               if target_type = 2
               {
                  AppendTempString("on the enemy ");
               }

               AppendTempString("with ");
               AppendTempString(Send(i,@GetSpellPower));
               AppendTempString(" spellpower ");
               AppendTempString(Send(i,@GetProcChance));
               AppendTempString("\% of the time.");
            }
         }
      }

      propagate;
   }
   
   GetAttackName()
   {
      return vrName;
   }

   GetRange()
   {
      return piRange;
   }

   GetMinDamage(who=$,what=$)
   {
      return piMinDamage;
   }
  
   GetMaxDamage(who=$,what=$)
   {
      return piMaxDamage;
   }

   GetProficiencyBonus(who=$,what=$)
   {
      return piProficiencyBonus;
   }

   GetHitMod(who=$,what=$,stroke_obj=$)
   {
      local i, iBonus;
      for i in plItem_Attributes
      {
         oWeapAtt = Send(SYS,@FindItemAttByNum,#num=Send(self,@GetNumFromCompound,#compound=First(i)));
         if IsClass(oWeapAtt,&WeaponAttribute)
         {
            iBonus = Send(oWeapAtt,@GetHitMod,#who=poOwner,#what=what,#lData=i);
         }
      }
      return piHitMod + iBonus;
   }

   GetBaseSpellModifier()
   {
      return piSpellpowerMod;
   }

   GetDisarmMod()
   {
      return piDisarmMod;
   }

   GetParryMod()
   {
      return piParryMod;
   }

   % This is called by the stroke to retrieve the relevant modifier.
   GetStrokeMod(Skill_num=0)
   {
      if Skill_num = SKID_STAB {  return piStab; }
      if Skill_num = SKID_STRIKE {  return piStrike; }
      if Skill_num = SKID_SLASH {  return piSlash; }
      if Skill_num = SKID_THRUST {  return piThrust; }
      if Skill_num = SKID_FIRE {  return piFire; }
      if Skill_num = SKID_TOUCH {  return piTouch; }
      
      return 100;
   }

   GetPrimaryStat()
   {
      return piPrimaryStat;
   }

   GetSecondaryStat()
   {
      return piSecondaryStat;
   }

   GetPrimaryScaling()
   {
      return piPrimaryScaling;
   }

   GetSecondaryScaling()
   {
      return piSecondaryScaling;
   }

   GetProfNum()
   {
      return viProficiency_needed;
   }

   GetStrokeNum(squareddistance=0)
   {
      if IsClass(self,&MagicWeapon)
      {
         return SKID_TOUCH;
      }

      if IsClass(self,&RangedWeapon)
      {
         return SKID_FIRE;
      }

      if squareddistance < 4
      {
         return SKID_STRIKE;
      }

      if squareddistance < 9
      {
         return SKID_SLASH;
      }

      return SKID_THRUST;
   }

   GetStrokeObject(squareddistance=0)
   {
      if IsClass(self,&MagicWeapon)
      {
         return Send(SYS,@FindSkillByNum,#num=SKID_TOUCH);
      }

      if IsClass(self,&RangedWeapon)
      {
         return Send(SYS,@FindSkillByNum,#num=SKID_FIRE);
      }

      if squareddistance < 4
      {
         return Send(SYS,@FindSkillByNum,#num=SKID_STRIKE);
      }

      if squareddistance < 9
      {
         return Send(SYS,@FindSkillByNum,#num=SKID_SLASH);
      }

      return Send(SYS,@FindSkillByNum,#num=SKID_THRUST);
   }

   % In most cases, we will return the player's ability in the stroke here, but
   % in some cases, such as touchattacks, we may determine the player's ability
   % in other ways. Since the way we determine the stroke ability depends on the
   % chosen weapon, we handle it here.
   GetStrokeAbility(who=$,Skill_num=0)
   {
      return Send(who,@GetSkillAbility,#Skill_num=Skill_num);
   }

   ImproveProficiency(who=$,target=$,bonus=0)
   {
      Send(Send(SYS,@findSkillbynum,#num=viProficiency_needed),@ImproveAbility,
            #who=who,#target=target,#bonus=bonus);

      return;
   }

   
   %%% Attack Type Functions (Enchanted weapons, Qor weapons, burning blades, etc.)

   GetAttackSpell()
   {
      return piAttack_spell;
   }

   GetAttackType()
   {
      return piAttack_type;
   }

   SetTypeFlag(flag=0, value=FALSE)
   {
      if value
      {
         piAttack_type = piAttack_type | flag;
      }
      else
      {
         piAttack_type = piAttack_type & ~flag;
      }

      return;
   }

   CheckTypeFlag(flag=0)
   {
      return (piAttack_type & flag);
   }

   SetSpellFlag(flag=0, value=FALSE)
   {
      if value
      {
         piAttack_spell = piAttack_spell | flag;
      }
      else
      {
         piAttack_spell = piAttack_spell & ~flag;
      }

      return;
   }

   CheckSpellFlag(flag=0)
   {
      return (piAttack_spell & flag);
   }


   %%%  Infrastructure

   ReqUseSomething(what=$)
   {
      if IsClass(what,&Weapon)
         OR IsClass(what,&Lute)
         OR IsClass(what,&JewelofFroz)
      {
         if Send(poOwner,@TryUnuseItem,#what=self)
         {
            propagate;
         }
         else
         {
            return FALSE;
         }
      }

      propagate;
   }

   WeaponHitTarget()
   {
      % 75% chance to be damaged, currently.
      if random(1,100) < WEAPON_TAKE_DAMAGE_PCT
      {
         piHits = piHits - 1;
      }

      if piHits <= 0
      {
         Send(self,@WeaponBroke);
      }

      return;
   }

   IsWeaponIntact()
   {
      if piHits <= 0
      {
         Send(poOwner,@MsgSendUser,#message_rsc=weapon_already_broken,
               #parm1=Send(self,@GetCapDef),#parm2=vrName);
         Send(poOwner,@TryUnuseItem,#what=self);

         return FALSE;
      }

      return TRUE;
   }

   ReqUseAmmo(ammotype=$)
   "At this point, a non-ranged weapon SHOULD never make it this far. "
   "This is just to catch anything that slips thru the cracks."
   "See ranged.kod for what this does."
   {
      Debug("A non-ranged weapon called @ReqUseAmmo!");

      return TRUE;
   }

   WeaponBroke()
   {
      local i, oItemAtt;

      % Remove itematts from us, since we're not gonna use 'em anymore.
      % This also lets cursed items finally remove themselves from us.
      for i in plItem_Attributes
      {
         oItemAtt = Send(SYS,@FindItemAttByNum,
                         #num=Send(self,@GetNumFromCompound,#compound=First(i)));
         Send(oItemAtt,@RemoveFromItem,#oItem=self);
      }

      Send(poOwner,@SomethingChanged,#what=self);
      Send(poOwner,@MsgSendUser,#message_rsc=vrWeaponBroke,
            #parm1=Send(self,@GetCapDef),#parm2=vrName);
      Send(poOwner,@TryUnuseItem,#what=self);

      return;
   }

   WeaponAttack()
   "Called by DoSwing in player when the weapon is actually used in an attack."
   {
      piUsed = ATTACKING;
      
      if vrWeapon_window_overlay <> $
      {
         Send(poOwner,@ChangeWindowOverlay,#what=self);
      }

      if vrWeapon_overlay <> $
      {
         Send(poOwner,@DoAttackSwing);
      }

      piUsed = USED;

      return;
   }

   NewUsed()
   {
      local oItemAtt;

      % This alerts Item attributes when item is used.
      % Currently special checks for "glowing" weapon attribute.
      if Send(self,@HasAttribute,#ItemAtt=WA_GLOWING)
      {
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=WA_GLOWING);
         Send(oItemAtt,@ItemUsed,#oItem=self,#oPlayer=poOwner);
      }

      piUsed = USED;

      % Do first person overlay if we have one
      if vrWeapon_window_overlay <> $
      {
         Send(poOwner,@SetWindowOverlay,#what=self);
      }

      % Do third person overlay if we have one
      if vrWeapon_overlay <> $
      {
         Send(poOwner,@SetOverlay,#what=self);
      }

      propagate;
   }

   NewUnused()
   {
      local oItemAtt;

      % This alerts Item attributes when item is used.
      % Currently special checks for "glowing" weapon attribute.
      if Send(self,@HasAttribute,#ItemAtt=WA_GLOWING)
      {
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=WA_GLOWING);
         Send(oItemAtt,@ItemUnused,#oItem=self,#oPlayer=poOwner);
      }

      piUsed = UNUSED;

      if vrWeapon_window_overlay <> $
      {
         Send(poOwner,@RemoveWindowOverlay,#what=self);
      }

      if vrWeapon_overlay <> $
      {
         Send(poOwner,@RemoveOverlay,#what=self);
      }

      propagate;
   }

   % Weapons may have a special on hit effect that scales with the weapon's
   % secondary stat. This effect may vary depending on the wielder, the target
   % and the stroke. For example, bows may use arrows that can shatter on
   % impact or do extra damage to undead targets. Swords may deal extra damage
   % from behind or be especially lethal against murderers.
   DoSpecialEffect(who=$,what=$,stroke_obj=$)
   {
      local iStat, iFactor;

      % Scale the effect with the weapon's secondary stat.
      iStat = Send(who,@GetStat,#stat=Send(self,@GetSecondaryStat));
      iFactor = Send(self,@GetSecondaryScaling);
      
      return 0;
   }

   %%% Animation Functions

   % these 5 called by player, for window overlays.
   % weapon subclasses--do NOT set a window overlay unless you either
   % set vrWeapon_window_overlay correctly or override all these message handlers
   GetWindowOverlay()
   {
      return vrWeapon_window_overlay;
   }

   GetWindowOverlayID()
   {
      return PWO_RIGHT_HAND;
   }

   GetWindowOverlayHotspot()
   {
      if piUsed = UNUSED
      {
         % turns off the window overlay
         return 0;
      }

      return HS_SE;
   }

   SendWindowOverlayAnimation()
   {
      local iFlags;

      iFlags = piItem_flags & ITEM_PALETTE_MASK;
      if iFlags <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION, 1,iFlags);
      }

      if piUsed = ATTACKING
      {
         AddPacket(1,ANIMATE_ONCE, 4,150, 2,vrWeapon_window_attack_start,
                   2,vrWeapon_window_attack_end, 2,vrWeapon_window_hold);
      }
      else
      {
         AddPacket(1,ANIMATE_NONE, 2,vrWeapon_window_hold);
      }

      return;
   }

   SendWindowOverlayOverlays()
   {
      % no overlays
      AddPacket(1,0);

      return;
   }

   % These 3 called by player, for normal 3rd-person overlays on user.
   % weapon subclasses--do NOT set a window overlay unless you either
   % set vrWeapon_overlay correctly or override all these message handlers

   GetOverlay(animation=$)
   {
      return vrWeapon_overlay;
   }

   GetOverlayHotspot(animation=$)
   {
      return HS_RIGHT_WEAPON;
   }

   SendOverlayAnimation(iAnimation=$)
   {
      local iFlags;

      iFlags = piItem_flags & ITEM_PALETTE_MASK;
      if iFlags <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION, 1,iFlags);
      }

      if iAnimation = PANM_WEAPON_ATTACK 
      {
         AddPacket(1,ANIMATE_ONCE, 4,300, 2,1, 2,3, 2,4);
      }
      else
      {
         AddPacket(1,ANIMATE_NONE, 2,4);
      }

      return;
   }

   SendOverlayInformation(ianimation=$)
   {
      AddPacket(4,Send(self,@GetOverlay));
      AddPacket(1,Send(self,@GetOverlayHotspot));
      Send(self,@SendOverlayAnimation,#iAnimation=iAnimation);

      return;
   }

   SendInventoryAnimation()
   {
      local iFlags;

      if piHits > 0 OR viBroken_group = $
      {
         propagate;
      }

      iFlags = piItem_flags & ITEM_PALETTE_MASK;
      if iFlags <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION, 1,iFlags);
      }

      AddPacket(1,ANIMATE_NONE, 2,viBroken_group);

      return;
   }

   SendLookAnimation()
   {
      local iFlags;

      if piHits > 0 OR viBroken_group = $
      {
         propagate;
      }

      if (piItem_flags & ITEM_PALETTE_MASK) <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION,1,piItem_flags & ITEM_PALETTE_MASK);
      }

      AddPacket(1,ANIMATE_NONE,2,viBroken_group);

      return;
   }

   SendAnimation()
   {
      local iFlags;

      if piHits > 0 OR viBroken_group = $
      {
         propagate;
      }

      iFlags = piItem_flags & ITEM_PALETTE_MASK;
      if iFlags <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION, 1,iFlags);
      }

      AddPacket(1,ANIMATE_NONE, 2,viBroken_group);

      return;
   }

   %%% Permission Functions

   CanMend()
   "Weapons are mendable, usually."
   {
      local i, oItemAtt;

      for i in plItem_Attributes
      {
         oItemAtt = Send(SYS,@FindItemAttByNum,
                         #num=Send(self,@GetNumFromCompound,#compound=First(i)));
         if oItemAtt = $
         {
            Debug("Illegal ItemAtt in list!");

            continue;
         }

         if NOT Send(oItemAtt,@ItemCanMend,#oItem=self)
         {
            return FALSE;
         }
      }

      return TRUE;
   }

   ValidateWeaponAttributes(num = 1)
   "Deletes any items with more major weapon attributes than num. Default 1."
   {
      local iNum;

      iNum = 0;

      if plItem_attributes = $
      {
         return;
      }

      if Send(self,@HasAttribute,#itematt=WA_BLINDER)
      {
         iNum = iNum + 1;
      }

      if Send(self,@HasAttribute,#itematt=WA_PARALYZER)
      {
         iNum = iNum + 1;
      }

      if Send(self,@HasAttribute,#itematt=WA_VAMPER)
      {
         iNum = iNum + 1;
      }

      if Send(self,@HasAttribute,#itematt=WA_PURGER)
      {
         iNum = iNum + 1;
      }

      if iNum > num
      {
         Post(self,@Delete);
         Debug("Multiple attribute weapon deleted.");
      }

      return;
   }

   CanEnchant(oSpell = $)
   "Weapons CAN usually be dedicated to Qor, Kraanan or Shal'ille.  "
   "Exception:  weapons that are already enchanted may not be, "
   "but this is taken care of on a spell by spell basis, so that reagents "
   "are used correctly."
   {
      local i, oItemAtt, iSpell;

      if piAttack_spell <> 0
         OR Send(self,@CheckTypeFlag,#flag=ATCK_WEAP_MAGIC)
      {
         iSpell = Send(oSpell,@GetSpellNum);
         if iSpell = SID_HOLY_WEAPON or iSpell = SID_UNHOLY_WEAPON
            OR iSpell = SID_ENCHANT_WEAPON
         {
            return TRUE;
         }
      }

      for i in plItem_Attributes
      {
         oItemAtt = Send(SYS,@FindItemAttByNum,
                         #num=Send(self,@GetNumFromCompound,#compound=First(i)));
         if oItemAtt = $
         {
            Debug("Illegal ItemAtt in list!");

            continue;
         }

         if NOT Send(oItemAtt,@ItemCanEnchant,#oItem=self)
         {
            return FALSE;
         }
      }

      return TRUE;
   }

   ReqRepair()
   {
      return TRUE;
   }

   CanBeDisarmed()
   {
      return TRUE;
   }

end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

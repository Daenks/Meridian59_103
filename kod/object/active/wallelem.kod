% Meridian 59, Copyright 1994-2012 Andrew Kirmse and Chris Kirmse.
% All rights reserved.
%
% This software is distributed under a license that is described in
% the LICENSE file that accompanies it.
%
% Meridian is a registered trademark.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
ActiveWallElement is ActiveObject

% Brambles, a monster-type wall element, uses code from this file.  If you
%  update this file, double-check the code in Brambles as well.

constants:

   include blakston.khd

   % 1.5 seconds
   EFFECT_INTERVAL = 1500

resources:

   ActiveWallElement_name_rsc = "wall element"
   ActiveWallElement_icon_rsc = poisoncl.bgf
   ActiveWallElement_desc_rsc = "This is a wall spell element."
   
   ActiveWallElement_dissipate_rsc = "The wall element dissipates."
   ActiveWallElement_unaffected_rsc = "You are unaffected by the wall element."

classvars:

   vrName = ActiveWallElement_name_rsc
   vrIcon = ActiveWallElement_icon_rsc
   vrdesc = ActiveWallElement_desc_rsc

   viObject_flags = LOOK_NO | MOVEON_NOTIFY

   vrDissipateMessage = ActiveWallElement_dissipate_rsc
   vrUnaffectedMessage = ActiveWallElement_unaffected_rsc

   % Flag to see if the wall element effect is harmful.
   vbIsHarmful = TRUE

   % Does this have a Periodic timer check?
   vbPeriodic = TRUE

   % Does the element affect the caster?
   vbCanAffectCaster = FALSE

properties:

   vbSummoned = FALSE

   poCaster = $
   ptExpire = $

   % This is the squared range that the element will affect.
   piRange = 0

   % This is a periodic timer that triggers periodic effects and
   %  clears the affected list.
   ptPeriodic = $

   % This is a list of objects already affected by the element
   %  this period.
   plAffected = $

   % The wallelement carries all relevant information in its seed. This allows 
   % the element to spawn additional elements that inherit their behavior from
   % the parent. plSeed has the following structure:
   % plSeed = [1caster,2spellpower,3duration,4charges,5speed,6direction,7step,8noise,9twirl,10seed]
   plSeed = $

   % The wallelement carries all relevant information in its seed. This allows 
   % the element to spawn additional elements that inherit their behavior from
   % the parent. plSeed has the following structure:
   % plSeed = [1caster,2spellpower,3duration,4charges,5speed,6direction,7step,8noise,9twirl,10seed]
   plSecondarySeed = $

   % Timer that spawns the next element upon expiration.
   ptSeed = $
   % Timer that may spawn a secondary seed upon expiration.
   ptSecondarySeed = $
   
messages:

   Constructor(seed=$)
   {
      plSeed = seed;

      poCaster = First(plSeed);

      if Nth(plSeed,3)
      {
         ptExpire = CreateTimer(self,@Expire,Nth(plSeed,3)+random(0,1000));
      }
      ptPeriodic = CreateTimer(self,@PeriodicEffect,
                        Send(self,@GetPeriodicDuration));

      if IsClass(First(plSeed),&User)
      {
         vbSummoned = TRUE;
      }

      % If we have a charge left, create a new element after an amount of ms
      % specified in speed.
      if Nth(plSeed,4) > 0 
      {
         ptSeed = CreateTimer(self,@SpawnNextElement,Nth(plSeed,5));
      }

      % If we have a secondary plSeed, spawn it afer the time specified.
      if Length(plSeed) > 9
      {
         plSecondarySeed = Send(SYS,@ListCopy,#source=Nth(plSeed,10));
         ptSecondarySeed = CreateTimer(self,@SpawnSecondaryElement,Nth(plSecondarySeed,5));
      }

      propagate;
   }

   SpawnNextElement()
   {
      local iRow, iCol, iFine_Row, iFine_Col, iXStep, iYStep, oElement, oRoom;

      ptSeed = $;
      oRoom = Send(self,@GetOwner);

      % Inherit the properties of the old element but remove one charge.
      setnth(plSeed,4,Nth(plSeed,4)-1);
      
      % If 'twirl' is enabled, shift the direction by 45 degrees every 'twirl' 
      % charges. Positive twirl rotates cw, negative twirl roates ccw.
      if Nth(plSeed,9) > 0 AND (Nth(plSeed,4) MOD Nth(plSeed,9)) = 0
      {
         if Nth(plSeed,6) = 7
         {
            setnth(plSeed,6,0);
         }
         else
         {
            setnth(plSeed,6,Nth(plSeed,6)+1);
         }
      }

      if Nth(plSeed,9) < 0 AND (Nth(plSeed,4) MOD (-Nth(plSeed,9))) = 0
      {
         if Nth(plSeed,6) = 0
         {
            setnth(plSeed,6,7);
         }
         else
         {
            setnth(plSeed,6,Nth(plSeed,6)-1);
         }
      }

      % First, let's interpret the seed's direction. If the direction is 0 or
      % invalid, let's assume it's north.
      iXStep = 0;
      iYStep = -1;

      % NorthEast
      if Nth(plSeed,6) = 1
      {
         iXStep = 1;
         iYStep = -1;
      }

      % East
      if Nth(plSeed,6) = 2
      {
         iXStep = 1;
         iYStep = 0;
      }

      % SouthEast
      if Nth(plSeed,6) = 3
      {
         iXStep = 1;
         iYStep = 1;
      }

      % South
      if Nth(plSeed,6) = 4
      {
         iXStep = 0;
         iYStep = 1;
      }

      % SouthWest
      if Nth(plSeed,6) = 5
      {
         iXStep = -1;
         iYStep= 1;
      }

      % West
      if Nth(plSeed,6) = 6
      {
         iXStep = -1;
         iYStep = 0;
      }

      % NorthWest
      if Nth(plSeed,6) = 7
      {
         iXStep = -1;
         iYStep = -1;
      }

      % Figure out where to spawn the next element based on our current
      % position, our direction, our stepsize and the randomization factor.
      iRow = Send(self,@GetRow) + iYStep * Nth(plSeed,7);
      iCol = Send(self,@GetCol) + iXStep * Nth(plSeed,7);
      
      iFine_Row = Send(self,@GetFineRow) + random(-Nth(plSeed,8),Nth(plSeed,8));
      if iFine_Row < 0
      {
         iFine_Row = iFine_Row + 64;
         iRow = iRow - 1;
      }
      if iFine_Row > 63
      {
         iFine_Row = iFine_Row - 64;
         iRow = iRow + 1;
      }

      iFine_Col = Send(self,@GetFineCol) + random(-Nth(plSeed,8),Nth(plSeed,8));
      if iFine_Col < 0
      {
         iFine_Col = iFine_Col + 64;
         iCol = iCol - 1;
      }
      if iFine_Col > 63
      {
         iFine_Col = iFine_Col - 64;
         iCol = iCol + 1;
      }
      
      oElement = Create(GetClass(self),#seed=plSeed);
      Send(oRoom,@NewHold,#what=oElement,#new_row=iRow,#new_col=iCol,
         #fine_row=iFine_Row,#fine_col=iFine_Col);

      return;
   }

   SpawnSecondaryElement()
   {
      local iRow, iCol, iFine_Row, iFine_Col, iXStep, iYStep, oElement, oRoom;

      ptSecondarySeed = $;
      oRoom = Send(self,@GetOwner);

      % Inherit the properties of the old element but remove one charge.
      setnth(plSecondarySeed,4,Nth(plSecondarySeed,4)-1);
      
      % If 'twirl' is enabled, shift the direction by 45 degrees every 'twirl' 
      % charges. Positive twirl rotates cw, negative twirl roates ccw.
      if Nth(plSecondarySeed,9) > 0 AND (Nth(plSecondarySeed,4) MOD Nth(plSecondarySeed,9)) = 0
      {
         if Nth(plSecondarySeed,6) = 7
         {
            setnth(plSecondarySeed,6,0);
         }
         else
         {
            setnth(plSecondarySeed,6,Nth(plSecondarySeed,6)+1);
         }
      }

      if Nth(plSecondarySeed,9) < 0 AND (Nth(plSecondarySeed,4) MOD (-Nth(plSecondarySeed,9))) = 0
      {
         if Nth(plSecondarySeed,6) = 0
         {
            setnth(plSecondarySeed,6,7);
         }
         else
         {
            setnth(plSecondarySeed,6,Nth(plSecondarySeed,6)-1);
         }
      }

      % First, let's interpret the seed's direction. If the direction is 0 or
      % invalid, let's assume it's north.
      iXStep = 0;
      iYStep = -1;

      % NorthEast
      if Nth(plSecondarySeed,6) = 1
      {
         iXStep = 1;
         iYStep = -1;
      }

      % East
      if Nth(plSecondarySeed,6) = 2
      {
         iXStep = 1;
         iYStep = 0;
      }

      % SouthEast
      if Nth(plSecondarySeed,6) = 3
      {
         iXStep = 1;
         iYStep = 1;
      }

      % South
      if Nth(plSecondarySeed,6) = 4
      {
         iXStep = 0;
         iYStep = 1;
      }

      % SouthWest
      if Nth(plSecondarySeed,6) = 5
      {
         iXStep = -1;
         iYStep= 1;
      }

      % West
      if Nth(plSecondarySeed,6) = 6
      {
         iXStep = -1;
         iYStep = 0;
      }

      % NorthWest
      if Nth(plSecondarySeed,6) = 7
      {
         iXStep = -1;
         iYStep = -1;
      }

      % Figure out where to spawn the next element based on our current
      % position, our direction, our stepsize and the randomization factor.
      iRow = Send(self,@GetRow) + iYStep * Nth(plSecondarySeed,7);
      iCol = Send(self,@GetCol) + iXStep * Nth(plSecondarySeed,7);
      
      iFine_Row = Send(self,@GetFineRow) + random(-Nth(plSecondarySeed,8),Nth(plSecondarySeed,8));
      if iFine_Row < 0
      {
         iFine_Row = iFine_Row + 64;
         iRow = iRow - 1;
      }
      if iFine_Row > 63
      {
         iFine_Row = iFine_Row - 64;
         iRow = iRow + 1;
      }

      iFine_Col = Send(self,@GetFineCol) + random(-Nth(plSecondarySeed,8),Nth(plSecondarySeed,8));
      if iFine_Col < 0
      {
         iFine_Col = iFine_Col + 64;
         iCol = iCol - 1;
      }
      if iFine_Col > 63
      {
         iFine_Col = iFine_Col - 64;
         iCol = iCol + 1;
      }
      
      oElement = Create(GetClass(self),#seed=plSecondarySeed);
      Send(oRoom,@NewHold,#what=oElement,#new_row=iRow,#new_col=iCol,
         #fine_row=iFine_Row,#fine_col=iFine_Col);

      return;
   }

   GetPeriodicDuration()
   {
      % 90 - 110% of base interval
      return (EFFECT_INTERVAL * Random(90,110))/100;
   }

   SomethingMoved(what = $,new_row = $,new_col = $)
   {
      local iRow, iCol;

      % Determine victim's row and column
      if new_row = $
      {
         iRow = Send(what,@GetRow);
      }
      else
      {
         iRow = new_row;
      }

      if new_col = $
      {
         iCol = Send(what,@GetCol);
      }
      else
      {
         iCol = new_col;
      }

      % Check for range
      if IsClass(what,&Battler)
         AND NOT (IsClass(what,&Player)
                  AND Send(what,@IsPhasedOut))
         AND Send(self,@InRange,#what=what,#iRow=iRow,#iCol=iCol)
      {
         Send(self,@CheckForEffect,#what=what,#new_row=iRow,#new_col=iCol,
               #bMovement=TRUE);
      }

      return;
   }

   CheckForEffect(what = $,new_row = $,new_col = $)
   "Check for range to see if we apply the effect."
   {
      local oRoom;

      oRoom = Send(self,@GetOwner);

      % Might not affect caster.
      if (NOT IsClass(what,&Battler))
         OR ((NOT vbCanAffectCaster) AND what = poCaster)
      {
         return FALSE;
      }

      % Don't affect them again this cycle.
      if plAffected <> $
         AND FindListElem(plAffected,what) <> 0
      {
         return FALSE;
      }

      % Don't affect users that haven't moved yet.
      if IsClass(what,&Player)
      {
         if NOT Send(what,@CheckPlayerFlag,#flag=PFLAG_MOVED_SINCE_ENTRY)
         {
            return FALSE;
         }
      }

      % If this is harmful, and both caster and victim are players, then
      % disallow damage if caster's safety is on or if cannot do attack.
      % AllowPlayerAttack also performs all the other required checks,
      % so they are no longer needed in this class.
      if vbIsHarmful
         AND IsClass(poCaster,&Player)
         AND NOT Send(poCaster,@AllowPlayerAttack,#victim=what,
                        #report=FALSE)
      {
         % We've been "affected" for this cycle.  This prevents super-spam.
         plAffected = Cons(what,plAffected);

         if IsClass(what,&Player)
            AND NOT Send(what,@IsPhasedOut)
         {
            Send(what,@MsgSendUser,#message_rsc=vrUnaffectedMessage);
         }

         return FALSE;
      }

      Send(self,@DoEffect,#what=what,#new_row=new_row,#new_col=new_col);

      return TRUE;
   }

   PeriodicEffect()
   "Periodic check. Clears the affected list, does the effect "
   "if the wall is periodic."
   {
      local i, oObject;

      ptPeriodic = $;
      plAffected = $;

      if vbPeriodic
      {
         for i in Send(poOwner,@GetHolderActive)
         {
            oObject = Send(poOwner,@HolderExtractobject,#data=i);
            if IsClass(oObject,&Battler)
               AND NOT (IsClass(oObject,&Player)
                  AND Send(oObject,@IsPhasedOut))
               AND Send(self,@InRange,#what=oObject,
                        #iRow=Send(oObject,@GetRow),
                        #iCol=Send(oObject,@GetCol))
            {
               Send(self,@CheckForEffect,#what=oObject);
            }
         }
      }

      ptPeriodic = CreateTimer(self,@PeriodicEffect,
                        Send(self,@GetPeriodicDuration));

      return;
   }

   DoEffect(what = $, new_row = $, new_col = $)
   "Apply the wall's effect to 'what'."
   {
      % Keep track that we've affected this object.
      plAffected = Cons(what,plAffected);

      return;
   }

   InRange(what = $,iRow = $,iCol = $,bMovement = FALSE)
   "Checks if we can see the target and if so if they are in range."
   {
      local iRow_diff, iCol_diff, iDistanceSquared, iLongRange;

      iRow_diff = Send(self,@GetRow) - iRow;
      iCol_diff = Send(self,@GetCol) - iCol;

      iDistanceSquared = iRow_diff * iRow_diff + iCol_diff * iCol_diff;

      % This first check is to see if they're within a one square range if
      % this check was caused by movement.  If so, we reset the user's move
      % counter, since we make them spam move messages which can throw
      % off speedhack detection.
      if bMovement
      {
         % Make sure we're checking at least 1 square away
         % from current position.
         iLongRange = Bound(piRange,1,$);
      }
      else
      {
         iLongRange = piRange;
      }

      if iDistanceSquared <= (iLongRange * iLongRange)
      {
         if (iLongRange = piRange
               OR iDistanceSquared <= (piRange * piRange))
            AND Send(poOwner,@LineOfSight,#obj1=self,#obj2=what)
         {
            return TRUE;
         }
      }

      return FALSE;
   }

   Expire()
   {
      ptExpire = $;
      Send(self,@Delete);

      return;
   }

   Delete()
   {
      poCaster = $;
      plAffected = $;

      if ptPeriodic <> $
      {
         DeleteTimer(ptPeriodic);
         ptPeriodic = $;
      }

      if ptSeed <> $
      {
         DeleteTimer(ptSeed);
         ptSeed = $;
      }

      if ptSecondarySeed <> $
      {
         DeleteTimer(ptSecondarySeed);
         ptSecondarySeed = $;
      }

      if ptExpire <> $
      {
         DeleteTimer(ptExpire);
         ptExpire = $;
      }

      propagate;
   }

   ReqNewOwner(what = $)
   {
      return IsClass(what,&Room);
   }

   NewOwner(what = $)
   {
      Post(self,@LocationCheck,#where=what);

      plAffected = $;

      propagate;
   }

   LocationCheck(where = $)
   {
      if (IsClass(where,&GuildHall)
            AND Send(where,@InFoyer,#who=poCaster))
         OR (Send(where,@IsArena)
            AND NOT Send(where,@InPlay,#what=self,#bNonPlayerOkay=TRUE))
      {
         if IsClass(poCaster,&Player)
         {
            Send(poCaster,@MsgSendUser,#message_rsc=vrDissipateMessage);
         }

         Post(self,@Delete);
      }

      return;
   }

   GetCaster()
   {
      return poCaster;
   }

end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

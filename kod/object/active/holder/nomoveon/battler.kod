% Meridian 59, Copyright 1994-2012 Andrew Kirmse and Chris Kirmse.
% All rights reserved.
%
% This software is distributed under a license that is described in
% the LICENSE file that accompanies it.
%
% Meridian is a registered trademark.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Battler is NoMoveOn

constants:

   include blakston.khd
   include protocol.khd

   % Raise or lower this number to raise or lower the chance the 'avoids 
   %  your attack' message comes up.
   BATTLER_AVOID_CHANCE = 50  

   % Threshold for the "wound" and "damage" levels of feedback.
   DAMAGE_THRESHOLD_WOUND = 500
   DAMAGE_THRESHOLD_DAMAGE = 1500

   % What's the maximum stat we can have after modification?
   MAXIMUM_STAT = 70

resources:

   % KNOWN BUG: placing a comment on the same line as a resource definition
   %  will comment out the next line.

   battler_blue_text = "~b"
   battler_plain_text = "~n"

   % battler_attacker_hit - Your scimitar wounds Psychochild for (10) damage.
   % battler_attacker_slay - Your scimitar slays Psychochild.
   % battler_attacker_miss - Your attack is blocked by Psychochild.
   % battler_attacker_fail - Your scimitar scrapes Psychochild, failing to cause any real harm.
   % battler_defender_hit - Psychochild's scimitar wounds you for (10) damage.
   % battler_defender_slay - Psychochild's scimitar slays you.
   % battler_defender_miss - Psychochild's attack is blocked by you.
   % battler_defender_fail - Psychochild's scimitar scrapes you, failing to cause any real harm.

   battler_attacker_hit = "%sYour %s %s %s%s for ~k~B%i~B%s damage."
   battler_attacker_slay = "%sYour %s %s %s%s."
   battler_attacker_miss = "%sYour attack %s %s%s."
   battler_attacker_fail = "%sYour %s %s %s%s, failing to cause any real harm."
   battler_defender_hit = "%s%s%s's %s %s you for ~r~B%i~B%s damage."
   battler_defender_slay = "%s%s%s's %s %s you."
   battler_defender_miss = "%s%s%s's attack %s you."
   battler_defender_fail = "%s%s%s's %s %s you, failing to cause any real harm."

   battler_punch = "punch"
   battler_attack = "attack"
   battler_blocked  = "is blocked by" 
   battler_dodged  = "is dodged by"
   battler_parried  = "is parried by"
   battler_misses = "misses"

   battler_fail = "barely touches"
   battler_nick = "nicks"
   battler_wound = "wounds"
   battler_damage = "damages"
   battler_slay = "slays"

   battler_acid_fail = "wets"
   battler_acid_nick = "burns"
   battler_acid_wound = "sears"
   battler_acid_damage = "disfigures"
   battler_acid_slay = "dissolves"

   battler_fire_fail = "warms"
   battler_fire_nick = "singes"
   battler_fire_wound = "chars"
   battler_fire_damage = "scorches"
   battler_fire_slay = "incinerates"

   battler_shock_fail = "tingles"
   battler_shock_nick =  "jolts"
   battler_shock_wound = "shocks"
   battler_shock_damage = "fries"
   battler_shock_slay = "electrocutes"

   battler_cold_fail = "refreshes"
   battler_cold_nick = "cools"
   battler_cold_wound = "chills"
   battler_cold_damage = "frosts"
   battler_cold_slay = "freezes"

   battler_holy_fail = "inspires"
   battler_holy_nick = "infuses"
   battler_holy_wound = "cleanses"
   battler_holy_damage = "exorcises"
   battler_holy_slay = "purifies"

   battler_unholy_fail = "unsettles"
   battler_unholy_nick = "maligns"
   battler_unholy_wound = "pollutes"
   battler_unholy_damage = "appalls"
   battler_unholy_slay = "corrupts"

   battler_quake_fail = "startles"
   battler_quake_nick = "shakes"
   battler_quake_wound = "buffets"
   battler_quake_damage = "slams"
   battler_quake_slay = "flattens"

   battler_bite_fail = "nips"
   battler_bite_nick = "gnaws"
   battler_bite_wound = "bites"
   battler_bite_damage = "tears into"
   battler_bite_slay = "devours"

   battler_claw_fail = "scratches"
   battler_claw_nick = "claws"
   battler_claw_wound = "rakes"
   battler_claw_damage = "rends"
   battler_claw_slay = "shreds"

   battler_sting_fail = "annoys"
   battler_sting_nick = "irritates"
   battler_sting_wound = "stings"
   battler_sting_damage = "pricks"
   battler_sting_slay = "impales"

   battler_punch_fail = "nudges"
   battler_punch_nick = "slaps"
   battler_punch_wound = "pummels"
   battler_punch_damage = "mangles"
   battler_punch_slay = "thrashes"

   battler_slash_fail = "scrapes"
   battler_slash_nick = "cuts"
   battler_slash_wound = "slashes"
   battler_slash_damage = "maims"
   battler_slash_slay = "cleaves"

   battler_bludgeon_fail = "bonks"
   battler_bludgeon_nick = "bashes"
   battler_bludgeon_wound = "crushes"
   battler_bludgeon_damage = "smashes"
   battler_bludgeon_slay = "brutalizes"

   battler_thrust_fail = "tickles"
   battler_thrust_nick = "pokes"
   battler_thrust_wound = "stabs"
   battler_thrust_damage = "impales"
   battler_thrust_slay = "runs through"

   battler_pierce_fail = "bounces off of"
   battler_pierce_nick = "grazes"
   battler_pierce_wound = "pierces"
   battler_pierce_damage = "lacerates"
   battler_pierce_slay = "fells"

classvars:

   viObject_flags = OF_ATTACKABLE

   viBattler_level = 50

properties:

   % Evil twin object
   poEvilTwin = $

   % List of active evil twins (i.e. ETs we've created).
   plEvilTwins = $

   % Apparition list and target
   plApparitionList = $
   poApparitionOriginal = $

   % Store minions
   plControlledMinions = $
   ptMinionControlCheck = $

   % list of resistances, Each element is [value, type].
   plResistances = $

   % List of enchantments.
   % Each element is [ timer, object of spell, [optional state] ].
   plEnchantments = $

   % Attack modifiers to attack roll & damage (includes items & spells)
   plAttack_modifiers = $

   % Defense modifiers to defense roll & damage (includes items & spells)
   plDefense_modifiers = $

   % Default mana values.
   piMana = 20
   piMax_Mana = 20

   % Mana regen timer.
   ptMana = $

   % Poison info
   ptPoison = $
   piPoisonStrength = 0

   %%% Variable battler values.

   % The player sees piMax_Health in their client.
   % piBase_Max_Health is their base without any modifiers
   % IMPORTANT NOTE: For higher accuracy, a battler's current health 
   %(and only current health) is inflated by a factor of 100. Doing so 
   % avoids truncation errors but is not revealed to users in any way.
   piHealth = 2000
   piMax_Health = 20
   piBase_Max_Health = 20

   % Governs health and mana replacement rates
   piVigor = 100
   % Accumulates small vigor debits from attacks, etc.
   piExertion = 0

   % Permanent battler base stats.
   piMight = 0
   piIntellect = 0
   piStamina = 0
   piAgility = 0
   piMysticism = 0
   piAim = 0

   % Modifiers to those base stats.
   piMightMod = 0
   piIntellectMod = 0
   piStaminaMod = 0
   piAgilityMod = 0
   piMysticismMod = 0
   piAimMod = 0

   % stuff in use
   plUsing = $

   % This list keeps track of selfcast buffs for passive improvement.
   plPassiveImprovement = $

messages:

   % The first lump of code here deals with resistances and immunities/etc.
   % They are included here in battler so both user and mobiles can enjoy
   %  the effect.

   TryDeflect()
   {
      return FALSE;
   }

   Delete()
   {
      local i;

      % Clear minion control list. Delete each of our minions
      % unless they are reflections, which are handled separately.
      % Deleted minions will remove themselves from our list, we
      % just need to let them know they're to be deleted.
      if plControlledMinions <> $
      {
         for i in plControlledMinions
         {
            if IsClass(i,&Monster)
               AND NOT IsClass(i,&Reflection)
            {
               Send(i,@Delete);
            }
         }
         plControlledMinions = $;
      }

      % If this Battler has created any evil twins, delete them.
      if plEvilTwins <> $
      {
         for i in plEvilTwins
         {
            Send(i,@Delete);
         }
         plEvilTwins = $;
      }

      % If this Battler has Apparitions attacking it, delete them.
      if plApparitionList <> $
      {
         for i in plApparitionList
         {
            Send(i,@Delete);
         }
         plApparitionList = $;
      }

      propagate;
   }

   ReqNewOwner(what = $)
   {
      return IsClass(what,&Room);
   }

   SayDyingWords(what=$)
   {
      return FALSE;
   }

   IsLikelyVictim()
   {
      % nearly all battlers can be attacked by a monster without provocation
      return TRUE;
   }

   IsUndead()
   {
      return FALSE;
   }

   % This checks if the battler can completely resist the effects of the spell.
   %  By default, the spell is not resisted.
   SpellResist(oSpell=$,who=$,iSpellpower=$)
   {
      return FALSE;
   }

   GetBaseResistances()
   "Many mobs have base resistances, but players do not. Monster.kod overwrites this."
   {
      return $;
   }
   
   GetCurrentResistances()
   "Object attributes, such as spells and items, can change resistances temporarily."
   {
      local oObjectAttribute, plCurrentResistances, oEquipment, oEnchantment;
      
      plCurrentResistances = Send(SYS,@ListCopy,#source=Send(self,@GetBaseResistances));
      
      for oObjectAttribute in plObject_attributes
      {
         plCurrentResistances = Send(oObjectAttribute,@ModifyResistance,#resistance_list=plCurrentResistances);
      }
      
      for oEquipment in Send(self,@GetEquippedItems)
      {
         plCurrentResistances = Send(oEquipment,@ModifyResistance,#resistance_list=plCurrentResistances);
      }
      
      If IsClass(self,&User)
      {
         for oEnchantment in Send(self,@GetEnchantmentList)
         {
            if Length(oEnchantment) > 2
            {
               plCurrentResistances = Send(Nth(oEnchantment,2),@ModifyResistance,#resistance_list=plCurrentResistances,#iState=Nth(oEnchantment,3));
            }
            else
            {
               plCurrentResistances = Send(Nth(oEnchantment,2),@ModifyResistance,#resistance_list=plCurrentResistances);
            }
         }
      }
      
      return plCurrentResistances;
   }

   GetEquippedItems()
   "Support for items equipped by players, but also some monsters, such as troops."
   {
      return $;
   }
 
   ResistanceCheck(atype = 0, aspell = 0)
   "Given bitvectors of attack type and spell, find the resistance modifier "
   "which applies. Largest resistance plus worst weakness gives the modifier."
   {
      local j, iResType, iMaxRes, iMinRes, iResistance, resistance_list;

      iMaxRes = NO_RESISTANCE;
      iMinRes = NO_RESISTANCE;
      
      resistance_list = Send(self,@GetCurrentResistances);

      for j in resistance_list
      {
         iResType = Nth(j,1);
         if iResType > 0   
         {
            % It's a resistance to weapon type

            if (atype & iResType) <> 0
               OR (atype <> 0 AND iResType = ATCK_WEAP_ALL)
            {
               iResistance = Nth(j,2);
               
               if iResistance > iMaxRes
               {
                  iMaxRes = iResistance;
               }

               if iResistance < iMinRes
               {
                  iMinRes = iResistance;
               }
            }
         }
         else
         {
            % It's a resistance to spell type
            iResType = -iResType;

            if (aspell & iResType) <> 0
               OR (aspell <> 0 AND iResType = ATCK_SPELL_ALL)
            {
               iResistance = Nth(j,2);
               
               if iResistance > iMaxRes
               {
                  iMaxRes = iResistance;
               }

               if iResistance < iMinRes
               {
                  iMinRes = iResistance;
               }
            }
         }
      }

      % clip to max/min values
      iMaxRes = bound(iMaxRes,$,MAX_RESISTANCE);
      iMinRes = bound(iMinRes,MIN_RESISTANCE,$);

      return iMaxRes + iMinRes;
   }

   GetDamageFromResistance(what = $, value = $)
   "Adjust <what> damage according to the value multiplier"
   {
      local iDamage;

      if value > NO_RESISTANCE
      {
         iDamage = what * (MAX_RESISTANCE - value) / MAX_RESISTANCE;
      }
      else
      {
         iDamage = what * (MIN_RESISTANCE + value) / MIN_RESISTANCE;
      }

      return iDamage;
   }

   %%% Spell enchantment functions.

   IsEnchanted(what=$,byClass=&Spell)
   "Returns whether or not currently enchanted by <what>."
   {
      local i;

      if what = $
      {
         for i in plEnchantments
         {
            if IsClass(Nth(i,2),byClass)
            {
               return TRUE;
            }
         }
      }
      else
      {
         for i in plEnchantments
         {
            if Nth(i,2) = what
            {
               return TRUE;
            }
         }
      }

      return FALSE;
   }

   GetEnchantedState(what=$)
   "If enchanted by <what>, returns the state data (which MUST exist, or it's an error.  "
   "In other words, the caller must know that <what> adds state data).  Returns $ otherwise."
   {
      local i;

      for i in plEnchantments
      {
         if Nth(i,2) = what
         {
            return Nth(i,3);
         }
      }

      return $;
   }

   GetEnchantmentsByClass(enchClass=&Spell)
   "returns a subset of plEnchantments whose elements are of the given class"
   {
      local i, returnList;
      returnList = $;

      for i in plEnchantments
      {
         if IsClass(Nth(i,2),enchClass)
         {
            returnList = Cons(i,returnList);
         }
      }

      return returnList;
   }

   GetEnchantmentList()
   {
      return plEnchantments;
   }

   GetCastPower(what=$)
   "This is used by purge to get the spellpower the personal enchantment was "
   "cast at. Put in Battler instead of Player as we may use this for monster "
   "buffs one day."
   {
      local i, iCastPower;

      for i in plEnchantments
      {
         if Nth(i,2) = what
         {
            if Length(i) > 3
            {
               iCastPower = Nth(i,4);
            }
            else
            {
               iCastPower = Nth(i,3);
            }
         }
      }

      return iCastPower;
   }

   %%% Mana related stuff common to players and mobs.

   GetMaxMana()
   {
      return piMax_mana;
   }

   GetMana()
   {
      return piMana;
   }

   ManaTimer()
   {
      ptMana = $;

      if piMana < piMax_mana
      {
         Send(self,@GainMana,#amount=1);
      }
      else
      {
         Send(self,@LoseMana,#amount=1);
      }

      return;
   }

   LoseMana(amount = 0)
   {
      local iManaLost;

      if IsClass(self,&Player)
         AND Send(self,@IsInCannotInteractMode)
      {
         return 0;
      }

      piMana = piMana - amount;
      if piMana < 0
      {
         iManaLost = amount - abs(piMana);
      }
      else
      {
         iManaLost = amount;
      }

      Send(self,@NewMana);

      return iManaLost;
   }

   GainMana(amount=0, bCapped=FALSE, bRespectMax=FALSE)
   {
      local iManaGained;

      iManaGained = amount;

      if IsClass(self,&Player)
         AND Send(self,@IsInCannotInteractMode)
      {
         return 0;
      }

      if bRespectMax
         AND piMana + amount > piMax_mana
      {
         return 0;
      }

      piMana = piMana + amount;

      if bCapped AND piMana > piMax_Mana
      {
         iManaGained = amount - (piMana - piMax_Mana);
         piMana = piMax_Mana;
      }

      Send(self,@NewMana);

      return iManaGained;
   }

   NewMana()
   {
      if piMana < 0
      {
         piMana = 0;
      }

      if piMana <> piMax_mana AND ptMana = $
      {
         ptMana = CreateTimer(self,@ManaTimer,Send(self,@CalculateManaTime));
      }

      if piMana = piMax_mana AND ptMana <> $
      {
         DeleteTimer(ptMana);
         ptMana = $;
      }

      if IsClass(self,&Player)
      {
         Send(self,@DrawMana);
      }

      return;
   }

   %%% Combat functionality.

   % All conditions have been checked at this point and the battler is eligible
   % to attack his target. TryAttack figures out whether he hits the target
   % based on his offense and the target's defense and passes this information
   % on to AssessDamage, AssessHit/AssessMiss etc.
   %
   % NOTES on settings: piEqualChanceToHit, piBaseRating and piDamageScaling can
   % be adjusted in settings.kod to tweak the calculations.
   % piEqualChanceToHit: This is the chance for an attacker to hit his target if
   % his defense equals the target's offense. A setting of 500 is equivalent to 
   % a 50 percent chance to hit.
   % piBaseRating: This is a flat number that serves as a base value for defense
   % and offense, softening the effect of any modifiers and avoiding
   % pathological ratios when one of the two battler's rating is extremely low.
   % piDamageScaling: This allows damage to scale when chance to hit exceeds 100
   % percent, allowing offense to be useful even when the target has very low
   % defense and we hit with every attack. People are less and less likely to 
   % run into this cap as piBaseRating is increased though.
   %
   % NOTE: For a monster, the stroke_obj is the monster itself for now.
   TryAttack(what = $,stroke_obj=$, is_ranged_attack=FALSE)
   {
      local iOffense, iDefense, iChanceToHit, iDamage, iScalefactor, oWeapon,
            lWindsState, lSandStormState;

      oWeapon = Send(self,@GetWeapon);

      % Special case:  Ranged weapons in windy room.
      if (oWeapon <> $ AND IsClass(oWeapon,&RangedWeapon))
         OR is_ranged_attack
      {
         lWindsState = Send(self,@GetMostPowerfulRadiusEnchantmentState,
                              #byClass=&Winds);
         lSandStormState = Send(self,@GetMostPowerfulRadiusEnchantmentState,
                              #byClass=&SandStorm);

         if lWindsState <> $
            AND Send(Nth(lWindsState,1),@TryRuinShot,#who=self,
                     #iSpellPower=Nth(lWindsState,2))
         {
            return FALSE;
         }

         if lSandStormState <> $
            AND Send(Nth(lSandStormState,1),@TryRuinShot,#who=self,
                     #iSpellPower=Nth(lSandStormState,2))
         {
            return FALSE;
         }
      }

      iOffense = Send(self,@GetOffense,#what=what,#stroke_obj=stroke_obj) 
         + Send(Send(SYS,@GetSettings),@GetBaseRating);
      iDefense = Send(what,@GetDefense,#what=self,#stroke_obj=stroke_obj) 
         + Send(Send(SYS,@GetSettings),@GetBaseRating);
      iChanceToHit = iOffense * Send(Send(SYS,@GetSettings),@GetEqualChanceToHit) / iDefense;
      iChanceToHit = bound(iChanceToHit,125,2000);
      if iChanceToHit >= random(1,1000)
      {
         % We hit!
         iDamage = Send(self,@GetDamage,#what=what,#stroke_obj=stroke_obj);
         iScalefactor = 1000;
         
         % Scale damage with chance to hit beyond 100 percent.
         if iChanceToHit > 1000 AND Send(Send(SYS,@GetSettings),@GetDamageScaling)
         {
            iScalefactor = iChanceToHit;
         }

         iDamage = Send(what,@AssessDamage,#what=self,#damage=iDamage,
            #atype=Send(self,@GetDamageType),#aspell=Send(self,@GetSpellType),
            #scalefactor=iScalefactor,#precision=TRUE);

         Send(self,@AssessHit,#what=what,#stroke_obj=stroke_obj,#damage=iDamage);

         if iDamage = $
         {
            Send(self,@KilledSomething,#what=what,#use_weapon=oWeapon,#stroke_obj=stroke_obj);
         }
         else
         {
            Send(self,@DidDamage,#amount=iDamage,#what=what);
         }
      }
      else
      {
         % Oops, a miss.  See if something happens.
         Send(self,@AssessMiss,#what=what,#stroke_obj=stroke_obj);
      }

      if poOwner <> $
      {
         Send(poOwner,@SomethingAttacked,#what=self,#victim=what,
              #use_weapon=oWeapon);
      }

      return TRUE;
   }
   
   GetLevel()
   {
      return 65;
   }

   GetOffense(what = $, stroke_obj=$)
   "Returns the battler's ability to-hit.  Ranges from 1 to 3000."
   {
      return 1;
   }

   GetDefense(what = $, stroke_obj=$)
   "Returns the battler's ability to avoid being hit.  Ranges from 1 to 3000."
   {
      return 1;
   }

   GetDamage(what = $, stroke_obj=$)
   "Returns the damage done to target 'what'."
   {
      return 0;
   }

   GetDamageType(what = $)
   "Returns the weapon type of damage done."
   {
      % Default type for the stub function.
      return ATCK_WEAP_HIT;
   }

   GetSpellType(what = $)
   "This is the magical type of damage done."
   {
      % Default, no spells
      return 0;
   }

   AssessDamage(what = $,damage = $,atype = $, aspell = $)
   "This applies damage to the battler, calculating appropriate resistances.  "
   "Return $ if we were killed."
   {
      return 0;
   }

   GetDamageDesc(damage=0, type=0)
   "This returns the severity of damage by type.  Gives a verb descriptor."
   {
      % For each type, Send unique words to describe the damage
      if type < 0
      {
         type = -type;
         if (type & ATCK_SPELL_FIRE)
         {
            if damage = $
            {
               return battler_fire_slay;
            }

            if damage > DAMAGE_THRESHOLD_DAMAGE
            {
               return battler_fire_damage;
            }

            if damage > DAMAGE_THRESHOLD_WOUND
            {
               return battler_fire_wound;
            }

            if damage > 99
            {
               return battler_fire_nick;
            }

            return battler_fire_fail;
         }

         if (type & ATCK_SPELL_SHOCK)
         {
            if damage = $
            {
               return battler_shock_slay;
            }

            if damage > DAMAGE_THRESHOLD_DAMAGE
            {
               return battler_shock_damage;
            }

            if damage > DAMAGE_THRESHOLD_WOUND
            {
               return battler_shock_wound;
            }

            if damage > 99
            {
               return battler_shock_nick;
            }

            return battler_shock_fail;
         }

         if (type & ATCK_SPELL_COLD)
         {
            if damage = $
            {
               return battler_cold_slay;
            }

            if damage > DAMAGE_THRESHOLD_DAMAGE
            {
               return battler_cold_damage;
            }

            if damage > DAMAGE_THRESHOLD_WOUND
            {
               return battler_cold_wound;
            }

            if damage > 99
            {
               return battler_cold_nick;
            }

            return battler_cold_fail;
         }

         if (type & ATCK_SPELL_ACID)
         {
            if damage = $
            {
               return battler_acid_slay;
            }

            if damage > DAMAGE_THRESHOLD_DAMAGE
            {
               return battler_acid_damage;
            }

            if damage > DAMAGE_THRESHOLD_WOUND
            {
               return battler_acid_wound;
            }

            if damage > 99
            {
               return battler_acid_nick;
            }

            return battler_acid_fail;
         }

         if (type & ATCK_SPELL_HOLY)
         {
            if damage = $
            {
               return battler_holy_slay;
            }

            if damage > DAMAGE_THRESHOLD_DAMAGE
            {
               return battler_holy_damage;
            }

            if damage > DAMAGE_THRESHOLD_WOUND
            {
               return battler_holy_wound;
            }

            if damage > 99
            {
               return battler_holy_nick;
            }

            return battler_holy_fail;
         }

         if (type & ATCK_SPELL_UNHOLY)
         {
            if damage = $
            {
               return battler_unholy_slay;
            }

            if damage > DAMAGE_THRESHOLD_DAMAGE
            {
               return battler_unholy_damage;
            }

            if damage > DAMAGE_THRESHOLD_WOUND
            {
               return battler_unholy_wound;
            }

            if damage > 99
            {
               return battler_unholy_nick;
            }

            return battler_unholy_fail;
         }

         if (type & ATCK_SPELL_QUAKE)
         {
            if damage = $
            {
               return battler_quake_slay;
            }

            if damage > DAMAGE_THRESHOLD_DAMAGE
            {
               return battler_quake_damage;
            }

            if damage > DAMAGE_THRESHOLD_WOUND
            {
               return battler_quake_wound;
            }

            if damage > 99
            {
               return battler_quake_nick;
            }

            return battler_quake_fail;
         }
      }
      else
      {
         if (type & ATCK_WEAP_BITE)
         {
            if damage = $
            {
               return battler_bite_slay;
            }

            if damage > DAMAGE_THRESHOLD_DAMAGE
            {
               return battler_bite_damage;
            }

            if damage > DAMAGE_THRESHOLD_WOUND
            {
               return battler_bite_wound;
            }

            if damage > 99
            {
               return battler_bite_nick;
            }

               return battler_bite_fail;
         }

         if (type & ATCK_WEAP_CLAW)
         {
            if damage = $
            {
               return battler_claw_slay;
            }

            if damage > DAMAGE_THRESHOLD_DAMAGE
            {
               return battler_claw_damage;
            }

            if damage > DAMAGE_THRESHOLD_WOUND
            {
               return battler_claw_wound;
            }

            if damage > 99
            {
               return battler_claw_nick;
            }

            return battler_claw_fail;
         }

         if (type & ATCK_WEAP_STING)
         {
            if damage = $
            {
               return battler_sting_slay;
            }

            if damage > DAMAGE_THRESHOLD_DAMAGE
            {
               return battler_sting_damage;
            }

            if damage > DAMAGE_THRESHOLD_WOUND
            {
               return battler_sting_wound;
            }

            if damage > 99
            {
               return battler_sting_nick;
            }

            return battler_sting_fail;
         }

         % Repeat the acid spell words here
         if (type & ATCK_WEAP_ACID)
         {
            if damage = $
            {
               return battler_acid_slay;
            }

            if damage > DAMAGE_THRESHOLD_DAMAGE
            {
               return battler_acid_damage;
            }

            if damage > DAMAGE_THRESHOLD_WOUND
            {
               return battler_acid_wound;
            }

            if damage > 99
            {
               return battler_acid_nick;
            }

            return battler_acid_fail;
         }

         if (type & ATCK_WEAP_PUNCH)
         {
            if damage = $
            {
               return battler_punch_slay;
            }

            if damage > DAMAGE_THRESHOLD_DAMAGE
            {
               return battler_punch_damage;
            }

            if damage > DAMAGE_THRESHOLD_WOUND
            {
               return battler_punch_wound;
            }

            if damage > 99
            {
               return battler_punch_nick;
            }

            return battler_punch_fail;
         }

         if (type & ATCK_WEAP_SLASH)
         {
            if damage = $
            {
               return battler_slash_slay;
            }

            if damage > DAMAGE_THRESHOLD_DAMAGE
            {
               return battler_slash_damage;
            }

            if damage > DAMAGE_THRESHOLD_WOUND
            {
               return battler_slash_wound;
            }

            if damage > 99
            {
               return battler_slash_nick;
            }

            return battler_slash_fail;
         }

         if (type & ATCK_WEAP_BLUDGEON)
         {
            if damage = $
            {
               return battler_bludgeon_slay;
            }

            if damage > DAMAGE_THRESHOLD_DAMAGE
            {
               return battler_bludgeon_damage;
            }

            if damage > DAMAGE_THRESHOLD_WOUND
            {
               return battler_bludgeon_wound;
            }

            if damage > 99
            {
               return battler_bludgeon_nick;
            }   

            return battler_bludgeon_fail;
         }

         if (type & ATCK_WEAP_THRUST)
         {
            if damage = $
            {
               return battler_thrust_slay;
            }

            if damage > DAMAGE_THRESHOLD_DAMAGE
            {
               return battler_thrust_damage;
            }

            if damage > DAMAGE_THRESHOLD_WOUND
            {
               return battler_thrust_wound;
            }

            if damage > 99
            {
               return battler_thrust_nick;
            } 

            return battler_thrust_fail;
         }

         if (type & ATCK_WEAP_PIERCE)
         {
            if damage = $
            {
               return battler_pierce_slay;
            }

            if damage > DAMAGE_THRESHOLD_DAMAGE
            {
               return battler_pierce_damage;
            }

            if damage > DAMAGE_THRESHOLD_WOUND
            {
               return battler_pierce_wound;
            }

            if damage > 99
            {
               return battler_pierce_nick;
            }
            
            return battler_pierce_fail;
         }
      }
      
      % Use these as the "default"
      if damage = $
      {
         return battler_slay;
      }

      if damage > DAMAGE_THRESHOLD_DAMAGE
      {
         return battler_damage;
      }

      if damage > DAMAGE_THRESHOLD_WOUND
      {
         return battler_wound;
      }

            if damage > 99
      {
         return battler_nick;
      }

      return battler_fail;
   }

   % This returns defense reason of why opponent missed this battler.
   GetDefenseDesc(stroke_obj=$)
   {
      local iRandom, iParry, iBlock, iDodge;
      
      iParry = Send(self,@GetParryAbility,#stroke_obj=stroke_obj);
      iBlock = Send(self,@GetBlockAbility,#stroke_obj=stroke_obj);
      iDodge = Send(self,@GetDodgeAbility,#stroke_obj=stroke_obj);
      iRandom = iParry + iBlock + iDodge + BATTLER_AVOID_CHANCE;
      iRandom = random(0,iRandom);

      if iRandom < iParry
      {
         return battler_parried;
      }

      if iRandom < (iParry + iBlock)
      {
         return battler_blocked;
      }

      if iRandom < (iParry + iBlock + iDodge)
      {
         return battler_dodged;
      }
      
      return battler_misses;
   }

   % The next three messages deal with the three defense skills.  These
   %  messages return the relative values of the three skills.  Used in
   %  player for defense, used in battler for defense messages.

   GetParryAbility(stroke_obj=$)
   {
      return 0;
   }

   GetBlockAbility(stroke_obj=$)
   {
      return 0;
   }

   GetDodgeAbility(stroke_obj=$)
   {
      return 0;
   }

   AssessHit(what = $, stroke_obj = $, damage = $, use_weapon=$)
   "This does the fallout of a hit, gives appropriate message, etc.  "
   "Called on self when hit opponent."
   {
      local rColor, oWeapon, rWeaponName, iDmg, rDamageDesc, iType;

      if use_weapon = $
      {
         oWeapon = Send(self,@GetWeapon);
      }
      else
      {
         oWeapon = use_weapon;
      }

      if oWeapon = $
      {
         rWeaponName = battler_punch;
      }
      else
      {
         % This returns the name of a melee weapon, the ammo of a ranged
         %  weapon, or the attack name for a monster.
         rWeaponName = Send(oWeapon,@GetAttackName);
      }

      % Spell types are usually represented by negative values, to
      %  differentiate between physical and spell damage.
      iType = Send(self,@GetSpellType,#use_weapon=use_weapon);

      % We only want to use a unique word if the spell damage is NOT generic
      %  or Hunter sword damage.  Otherwise, use the physical damage type.
      if (iType & (~ATCK_SPELL_HUNTERSWORD | ~ATCK_SPELL_ALL)) = 0
      {
         iType = Send(self,@GetDamageType,#use_weapon=use_weapon);
      }
      else
      {
         % Make it negative to distinguish between physical types.
         iType = -iType;
      }

      if IsClass(what,&Player)
         AND damage <> $
         AND damage >= (Send(what,@GetMaxHealth)*33)
      {
         % If we did at least 1/3 a player's hps in damage, then give
         %  the best damage message.
         iDmg = (DAMAGE_THRESHOLD_DAMAGE + 1);
      }
      else
      {
         iDmg = damage;
      }

      rDamageDesc = Send(self,@GetDamageDesc,#damage=iDmg,#type=iType);      
      rColor = battler_blue_text;

      if IsClass(self,&Player)
      {
         if Send(self,@CheckPlayerFlag,#flag=PFLAG_MORPHED) 
         {
            % Don't use "punch" if we're morphed, use a more generic term.
            if oWeapon = $
            {
               rWeaponName = battler_attack;
            }
         }


         if IsClass(what,&Player) AND NOT Send(what,@CheckPlayerFlag,#flag=PFLAG_MORPHED) 
         {
            rColor = battler_plain_text;
         }
         else
         {
            rColor = battler_blue_text;
         }

         if what <> self
         {
            if damage = $
            {
               Send(self,@MsgSendUser,#message_rsc=battler_attacker_slay,
               #parm1=rColor,#parm2=rWeaponName,#parm3=rDamageDesc,
               #parm4=Send(what,@GetDef),#parm5=Send(what,@GetName));
            }
            else
            {
               if damage > 99
               {
                  Send(self,@MsgSendUser,#message_rsc=battler_attacker_hit,
                  #parm1=rColor,#parm2=rWeaponName,#parm3=rDamageDesc,
                  #parm4=Send(what,@GetDef),#parm5=Send(what,@GetName),
                  #parm6=damage/100,#parm7=rColor);
               }
               else
               {
                  Send(self,@MsgSendUser,#message_rsc=battler_attacker_fail,
                  #parm1=rColor,#parm2=rWeaponName,#parm3=rDamageDesc,
                  #parm4=Send(what,@GetDef),#parm5=Send(what,@GetName));
               }
            }
         }
      }

      if IsClass(what,&Player)
      {
         if IsClass(self,&Player) AND NOT Send(self,@CheckPlayerFlag,#flag=PFLAG_MORPHED) 
         {
            rColor = battler_plain_text;
         }
         else
         {
            rColor = battler_blue_text;
         }
      
         if damage = $
         {   
            Send(what,@MsgSendUser,#message_rsc=battler_defender_slay,
              #parm1=rColor,#parm2=Send(self,@GetCapDef),
              #parm3=Send(self,@GetName),#parm4=rWeaponName,
              #parm5=rDamageDesc);
         }
         else
         {
            if damage > 99
            {
               Send(what,@MsgSendUser,#message_rsc=battler_defender_hit,
                 #parm1=rColor,#parm2=Send(self,@GetCapDef),
                 #parm3=Send(self,@GetName),#parm4=rWeaponName,
                 #parm5=rDamageDesc,#parm6=damage/100,#parm7=rColor);
            }
            else
            {
               Send(what,@MsgSendUser,#message_rsc=battler_defender_fail,
                 #parm1=rColor,#parm2=Send(self,@GetCapDef),
                 #parm3=Send(self,@GetName),#parm4=rWeaponName,
                 #parm5=rDamageDesc);
            }
         }
      }

      return;
   }

   AssessMiss(what = $, stroke_obj = $)
   "This does the fallout of a miss, gives appropriate message, etc. "
   "Called on self when missing."
   {
      local rColor;

      % This is kinda kludgy, should call messages in subclasses instead.
      if IsClass(self,&Player)
      {
         if IsClass(what,&Player) AND NOT Send(what,@CheckPlayerFlag,#flag=PFLAG_MORPHED) 
         {
            rColor = battler_plain_text;
         }
         else
         {
            rColor = battler_blue_text;
         }

         Send(self,@MsgSendUser,#message_rsc=battler_attacker_miss,
              #parm1=rColor,
              #parm2=Send(what,@GetDefenseDesc,#stroke_obj=stroke_obj),
              #parm3=Send(what,@GetDef),
              #parm4=Send(what,@GetName));
         Send(stroke_obj,@SendMissMessageToAttacker,#who=self,#victim=what,
              #color_rsc=rColor,#weapon_used=Send(self,@LookupPlayerWeapon),
              #bText=FALSE);
      }

      if IsClass(what,&Player)
      {
         if IsClass(self,&Player) AND NOT Send(self,@CheckPlayerFlag,#flag=PFLAG_MORPHED) 
         {
            rColor = battler_plain_text;
         }
         else
         {
            rColor = battler_blue_text;
         }
      
         Send(what,@MsgSendUser,#message_rsc=battler_defender_miss,
              #parm1=rColor,
              #parm2=Send(self,@GetCapDef),
              #parm3=Send(self,@GetName),
              #parm4=Send(what,@GetDefenseDesc,#stroke_obj=stroke_obj));
         % Flag them as "dodging", so they can potentially improve.
         Send(what,@SetPlayerFlag,#flag=PFLAG_DODGED,#value=TRUE);              
      }

      return;
   }

   % This function handles when damage is done by attacker.
   DidDamage(what=$, amount=0)
   {
      return;
   }

   % This function is called when we killed something.
   KilledSomething(what=$,use_weapon=$,stroke_obj=$)
   {
      return;
   }

   % Oo, 'e died
   Killed(what = $)
   {
      return;
   }

   MsgPlayerHitResisted()
   {
      return;
   }
   
   GetResistances()
   {
      return Send(self,@GetCurrentResistances);
   }
   
   GetResistanceValueByType(type=$)
   {
      local oResist;
      
      for oResist in Send(self,@GetCurrentResistances)
      {
         if Nth(oResist,1) = type
         {
            return Nth(oResist,2);
         }
      }
      
      return 0;
   }

   % This section deals with minion control code.
   % Player and Monster both have a copy of CommandMinionAttack.

   NewControlledMinion(minion=$)
   {
      if ptMinionControlCheck = $
      {
         CreateTimer(self,@MinionControlCheck,2000);
      }

      plControlledMinions = Cons(minion,plControlledMinions);

      return;
   }

   RemoveControlledMinion(what=$)
   {
      if plControlledMinions <> $
      {
         % Use FindListElem; there are rare cases where we have
         % a valid minion that doesn't go on our control list.
         if FindListElem(plControlledMinions,what)
         {
            plControlledMinions = DelListElem(plControlledMinions,what);
         }
      }

      return;
   }

   GetControlledMinions()
   {
      return plControlledMinions;
   }

   CheckBattlerMinionCount()
   {
      local i,iMinionCount;

      iMinionCount = 0;

      for i in plControlledMinions
      {
         if NOT IsClass(i,&Reflection)
         {
            iMinionCount = iMinionCount + 1;
         }
      }

      return iMinionCount;
   }

   MinionControlCheck()
   {
      local i;

      if Length(plControlledMinions) > 0
      {
         for i in plControlledMinions
         {
            if Send(i,@GetMaster) <> self
            {
               Send(self,@RemoveControlledMinion,#what=i);

               continue;
            }

            if Send(i,@GetTarget) = $
            {
               Send(i,@SetBehaviorFlag,#flag=AI_MOVE_FOLLOW_MASTER,
                     #value=TRUE);
            }
         }
         CreateTimer(self,@MinionControlCheck,2000);
      }
      else
      {
         if ptMinionControlCheck <> $
         {
            DeleteTimer(ptMinionControlCheck);
         }
         ptMinionControlCheck = $;
      }

      return;
   }

   % This section deals with illusions cast by/on the battler

   AddEvilTwin(what=$)
   "If something casts evil twin on us, we store it here."
   {
      if poEvilTwin = $
      {
         poEvilTwin = what;

         return TRUE;
      }

      return FALSE;
   }

   RemoveEvilTwin()
   {
      if poEvilTwin <> $
      {
         poEvilTwin = $;

         return TRUE;
      }

      return FALSE;
   }

   HasEvilTwin()
   {
      if poEvilTwin <> $
      {
         return TRUE;
      }

      return FALSE;
   }

   EvilTwinsCreated(what=$)
   "If we cast evil twin on something, we add the ET to our "
   "list of created evil twins."
   {
      if what <> $
      {
         plEvilTwins = Cons(what,plEvilTwins);
      }

      return;
   }

   RemoveCreatedEvilTwin(what=$)
   "Remove an evil twin from our list of created evil twins."
   {
      local i;

      if plEvilTwins <> $
         AND FindListElem(plEvilTwins,what)
      {
         plEvilTwins = DelListElem(plEvilTwins,what);
      }

      return;
   }

   % If Apparition is cast on the monster, this list keeps track of it.
   AddApparition(what=$)
   {
      if what <> $
      {
         plApparitionList = Cons(what,plApparitionList);
      }

      return;
   }

   % If this monster is an Apparition, this keeps track of the original target.
   AddApparitionOriginal(what=$)
   {
      poApparitionOriginal = what;

      return;
   }

   % If an Apparition targeting this monster is deleted, remove it from list.
   RemoveApparition(what=$)
   {
      local i;

      for i in plApparitionList
      {
         if i = what
         {
            plApparitionList = DelListElem(plApparitionList,i);
         }
      }

      if Length(plApparitionList) = 0
         {
            plApparitionList = $;
         }

      return;
   }

   GetBoostedLevel()
   {
      return 0;
   }

   EnchantmentTimer(timer = $)
   {
      local i, j, oEnchanter;

      for i in plEnchantments
      {
         if First(i) = timer
         {
            if Length(i) >= 3
            {
               Send(Nth(i,2),@EndEnchantment,#who=self,#state=Nth(i,3));
            }
            else
            {
               Send(Nth(i,2),@EndEnchantment,#who=self);
            }

            if IsClass(self,&Player)
            {
               Send(self,@ShowRemoveEnchantment,#what=Nth(i,2),
                    #type=ENCHANTMENT_PLAYER);
            }

            % TODO: i no longer exists at this point?
            % EndEnchantment removing it?
            plEnchantments = DelListElem(plEnchantments,i);
            
            % Also remove from passive improvement list.
            if IsClass(self,&Player)
            {
               for j in plPassiveImprovement
               {
                  if First(j) = Nth(i,2)
                  {
                     plPassiveImprovement = DelListElem(plPassiveImprovement,j);
                  }
               }

               if IsClass(Nth(i,2),&Mirth)
                  OR IsClass(Nth(i,2),&Melancholy)
               {
                  Send(self,@ResetPlayerFlagList,#nodraw=TRUE,#who=self);
               }
               else
               {
                  Send(self,@ResetPlayerFlagList,#who=self);
               }
            }

            if poOwner <> $
            {
               Send(poOwner,@SomethingChanged,#what=self);
            }

            return;
         }
      }

      Debug("Enchantment timer went off with no enchantment",timer);

      return;
   }

   PeriodicEnchantmentTimer(timer = $)
   {
      local i ;

      for i in plEnchantments
      {
         if First(i) = timer
         {
            plEnchantments = DelListElem(plEnchantments,i);

            if Length(i) >= 3
            {
               Send(Nth(i,2),@StartPeriodicEnchantment,
                     #who=self,#state=Nth(i,3));
            }
            else
            {
               Send(Nth(i,2),@StartPeriodicEnchantment,#who=self,#state=$);
            }

            return;
         }
      }

      Debug("Enchantment timer went off with no enchantment",timer);

      return;
   }

   StartEnchantment(what=$,who=$,time=$,state=$,lastcall=TRUE,
                     addicon=TRUE,ltype=$)
   "Adds <what> to our enchantments, and creates a timer that will cause it "
   "to end."
   {
      local oTimer, lNew_enchantment;

      if time = $ OR time = SPELL_INDEFINITE_DURATION 
      {
         oTimer = $;
      }
      else
      {
         if lastcall
         {
            oTimer = CreateTimer(self,@EnchantmentTimer,time);
         }
         else
         {
            oTimer = CreateTimer(self,@PeriodicEnchantmentTimer,time);
         }
      }

      if state = $
      {
         lNew_enchantment = [oTimer, what];
      }
      else
      {
         lNew_enchantment = [oTimer, what, state];
      }

      plEnchantments = Cons(lNew_enchantment,plEnchantments);

      if IsClass(self,&Player)
      {
         % If we are also the source of the enchantment, add the enchantment
         % to our passive improvement list. ltype has the form:
         % [oSpell,Defensive,Offensive,Resistance]
         if who = self
            AND IsClass(self,&Player)
         {
            plPassiveImprovement = Cons(ltype,plPassiveImprovement);
         }
      
         if IsClass(what,&Mirth)
            OR IsClass(what,&Melancholy)
         {
            Send(self,@ResetPlayerFlagList,#nodraw=TRUE,#who=self);
         }
         else
         {
            Send(self,@ResetPlayerFlagList,#who=self);
         }

         if addicon
         {
            Send(self,@ShowAddEnchantment,#what=what,#type=ENCHANTMENT_PLAYER);
         }

         Post(self,@DrawResistances);
      }

      return;
   }

   RemoveAllEnchantments(report=TRUE)
   "Remove all current enchantments and reset the passive improvement list."
   {
      local i;

      for i in plEnchantments
      {
         if NOT IsClass(Nth(i,2),&RadiusEnchantment)
         {
            Send(self,@RemoveEnchantment,#what=Nth(i,2),#report=report);
         }
      }

      if IsClass(self,&Player)
      {
         plPassiveImprovement = $;
      }

      return;
   }

   RemoveAllPersonalEnchantments(report=TRUE,override=FALSE)
   "Remove all current *personal* enchantments and reset "
   "the passive improvement list."
   {
      local i, oSpell, removedSomething;

      removedSomething = FALSE;

      for i in plEnchantments
      {
         oSpell = Nth(i,2);
         if Send(oSpell,@IsPersonalEnchantment)
            AND ((NOT IsClass(oSpell,&DMSpell)) OR override)
         {
            Send(self,@RemoveEnchantment,#what=Nth(i,2),#report=report);
            removedSomething = TRUE;
         }
      }

      if IsClass(self,&Player)
      {
         % Just to be sure, reset the player's flag list.
         % this should remove any excess flags like invis or shadowform.
         Send(self,@ResetPlayerFlagList);
         Send(self,@ResetPlayerDrawfx,#SendSomethingChanged=TRUE);

         plPassiveImprovement = $;
      }

      return removedSomething;
   }

   DispelIllusionEnchantments(report = TRUE, iChance = 100)
   {
      local i, oSpell, each_obj;

      for i in plEnchantments 
      {
         oSpell = Nth(i,2);
         if Send(oSpell,@IsIllusion)
            AND Random(1,100) <= iChance
         {
            Send(self,@RemoveEnchantment,#what=Nth(i,2),#report=report);
         }
      }

      return;
   }

   RemoveSchoolEnchantments(school = $,report=TRUE)
   {
      local i, oSpell, each_obj;

      for i in plEnchantments
      {
         oSpell = Nth(i,2);
         if Send(oSpell,@GetSchool) = school
         {
            Send(self,@RemoveEnchantment,#what=Nth(i,2),#report=report);
         }
      }

      return;
   }

   RemoveEnchantment(what = $, report=TRUE)
   "If have a current enchantment set by <what>, end it."
   {
      local i,state;

      state = $ ;

      for i in plEnchantments
      {
         if Nth(i,2) = what
         {
            if Send(self,@IsLoggedOn)
               OR IsClass(what,&Phase)
            {
               if First(i) <> $
               {
                  if IsTimer(First(i))
                  {
                     DeleteTimer(First(i));
                  }
                  SetNth(i,1,$);
               }
            }
            if Length(i) >= 3
            {
               state = Nth(i,3);
            }

            Send(Nth(i,2),@RemoveEnchantmentEffects,#who=self,
                  #state=state,#report=report);

            if IsClass(self,&Player)
            {
               Send(self,@ShowRemoveEnchantment,#what=Nth(i,2),
                     #type=ENCHANTMENT_PLAYER);
            }

            plEnchantments = DelListElem(plEnchantments,i);

            if IsClass(self,&Player)
            {
               if IsClass(what,&Mirth)
                  OR IsClass(what,&Melancholy)
               {
                  Send(self,@ResetPlayerFlagList,#nodraw=TRUE,#who=self);
               }
               else
               {
                  Send(self,@ResetPlayerFlagList,#who=self);
               }
            }
         }
      }

      if IsClass(self,&Player)
      {
         % Also remove from passive improvement list.
         for i in plPassiveImprovement
         {
            if First(i) = what
            {
               plPassiveImprovement = DelListElem(plPassiveImprovement,i);
            }
         }
      }

      return;
   }

   RemoveEnchantmentClass(class = &Object)
   "If have a current enchantment set by anything in class, end it."
   {
      local i,state,removedSomething;

      removedSomething = FALSE;

      for i in plEnchantments
      {
         if IsClass(Nth(i,2),class)
         {
            removedSomething = TRUE;
            if First(i) <> $
            {
               DeleteTimer(First(i));
            }

            if Length(i) >= 3
            {
               state = Nth(i,3);
            }

            Send(Nth(i,2),@RemoveEnchantmentEffects,#who=self,#state=state);

            if IsClass(self,&Player)
            {
               Send(self,@ShowRemoveEnchantment,#what=Nth(i,2),
                     #type=ENCHANTMENT_PLAYER);
            }

            plEnchantments = DelListElem(plEnchantments,i);
            
            if IsClass(self,&Player)
            {
               Send(self,@ResetPlayerFlagList,#who=self);
            }
         }
      }

      if IsClass(self,&Player)
      {
         % Also remove from passive improvement list.
         for i in plPassiveImprovement
         {
            if IsClass(First(i),class)
            {
               plPassiveImprovement = DelListElem(plPassiveImprovement,i);
            }
         }
      }

      return removedSomething;
   }

   AddAttackModifier(what = $)
   "Adds <what> to plAttack_modifiers, which can modify attack "
   "strength and damage."
   {
      plAttack_modifiers = Cons(what,plAttack_modifiers);
      
      if IsClass(self,&Player)
      {
         Post(self,@DrawOffense);
      }

      return;
   }

   RemoveAttackModifier(what = $)
   "Removes <what> from plAttack_modifiers."
   {
      local i;

      for i in plAttack_modifiers
      {
         if i = what
         {
            plAttack_modifiers = DelListElem(plAttack_modifiers,i);
            
            if IsClass(self,&Player)
            {
               Post(self,@DrawOffense);
            }

            return;
         }
      }

      return;
   }

   AddDefenseModifier(what = $)
   "Adds <what> to plDefense_modifiers, which can modify defense strength "
   "and damage."
   {
      plDefense_modifiers = Cons(what,plDefense_modifiers);
      
      if IsClass(self,&Player)
      {
         Post(self,@DrawDefense);
         Post(self,@DrawArmor);
      }

      return;
   }

   RemoveDefenseModifier(what = $)
   "Removes <what> from plDefense_modifiers."
   {
      local i;

      for i in plDefense_modifiers
      {
         if i = what
         {
            plDefense_modifiers = DelListElem(plDefense_modifiers,i);
            
            if IsClass(self,&Player)
            {
               Post(self,@DrawDefense);
               Post(self,@DrawArmor);
            }
            
            return;
         }
      }
      
      Debug(self,"Tried to remove defense modifier",what,"but not in list",
               plDefense_modifiers);

      return;
   }

   AddPoison(strength = 0, bVigorLoss = TRUE)
   {
      if ptPoison = $
      {
         ptPoison = CreateTimer(self,@PoisonTimer,10000);
      }

      piPoisonStrength = piPoisonStrength + strength;

      if bVigorLoss
         AND IsClass(self,&Player)
      {
         piVigor = piVigor - 20;
         Send(self,@NewVigor);
      }

      return;
   }

   RemovePoison(strength = 0)
   {
      piPoisonStrength = piPoisonStrength - strength;

      return;
   }

   PoisonTimer()
   {
      ptPoison = $;

      % For safety's sake
      if piPoisonStrength <= 0
      {
         piPoisonStrength = 0;

         return;
      }

      if poOwner = $
      {
         return;
      }

      ptPoison = CreateTimer(self,@PoisonTimer,10000);

      if IsClass(self,&Player)
         AND Send(self,@IsInCannotInteractMode)
      {
         return;
      }

      if NOT Send(poOwner,@SafePlayerAttack)
         OR Send(poOwner,@IsValidTarget,#who=self)
      {
         % Poison only hurts you in the arena if you are a combatant.
         piHealth = piHealth - piPoisonStrength / 1000;
         if piHealth < 1
         {
            piHealth = 1;
         }

         if IsClass(self,&Player)
         {
            Send(self,@NewHealth);
         }
      }

      return;
   }

   Delete()
   {
      if ptPoison <> $
      {
         DeleteTimer(ptPoison);
         ptPoison = $;
      }
      propagate;
   }
   

   AddMight(points = 0, bAbsolute = TRUE)
   "Returns signed change to might (negative means decrease)"
   "If restore = TRUE, ignore the bounds check and add the amount anyway."
   {
      local iOrigMight;

      iOrigMight = piMightMod;
      piMightMod = piMightMod + points;

      if NOT bAbsolute
      {
         piMightMod = bound(piMightMod,-piMight,(MAXIMUM_STAT-piMight));
      }

      if IsClass(self,&Player)
      {
         Send(self,@DrawMight);
         Post(self,@DrawCapacity);
      }

      return piMightMod - iOrigMight;
   }

   AddIntellect(points = 0, bAbsolute = TRUE)
   "Returns signed change to intellect (negative means decrease)"
   "If restore = TRUE, ignore the bounds check and add the amount anyway."
   {
      local iOrigIntellect;

      iOrigIntellect = piIntellectMod;
      piIntellectMod = piIntellectMod + points;

      if NOT bAbsolute
      {
         piIntellectMod = bound(piIntellectMod,-piIntellect,(MAXIMUM_STAT-piIntellect));
      }

      if IsClass(self,&Player)
      {
         Send(self,@DrawIntellect);
      }

      return piIntellectMod - iOrigIntellect;
   }

   AddAim(points = 0, bAbsolute = TRUE)
   "Returns signed change to aim (negative means decrease)"
   "If restore = TRUE, ignore the bounds check and add the amount anyway."
   {
      local iOrigAim;

      iOrigAim = piAimMod;
      piAimMod = piAimMod + points;

      if NOT bAbsolute
      {
         piAimMod = bound(piAimMod,-piAim,(MAXIMUM_STAT-piAim));
      }

      if IsClass(self,&Player)
      {
         Send(self,@DrawAim);
         Post(self,@DrawOffense);
      }

      return piAimMod - iOrigAim;
   }

   AddStamina(points = 0, bAbsolute = TRUE, scale_up_monster_health = FALSE)
   "Returns signed change to stamina (negative means decrease)"
   "If restore = TRUE, ignore the bounds check and add the amount anyway."
   {
      local iOrigStamina;

      iOrigStamina = piStaminaMod;
      piStaminaMod = piStaminaMod + points;

      if NOT bAbsolute
      {
         piStaminaMod = bound(piStaminaMod,-piStamina,(MAXIMUM_STAT-piStamina));
      }

      if IsClass(self,&Player)
      {
         Send(self,@DrawStamina);
      }
      if IsClass(self,&Monster)
         AND scale_up_monster_health
      {
         piHealth=(Send(self,@GetHealth) * 
                      (100+Send(self,@GetStamina)))/100;
                      
         piBase_max_health=(Send(self,@GetBaseMaxHealth) *
                      (100+Send(self,@GetStamina)))/100;
                      
         piMax_health=(Send(self,@GetMaxHealth) *
                      (100+Send(self,@GetStamina)))/100;
      }

      return piStaminaMod - iOrigStamina;
   }

   AddAgility(points = 0, bAbsolute = TRUE)
   "Returns signed change to agility (negative means decrease)"
   "If restore = TRUE, ignore the bounds check and add the amount anyway."
   {
      local iOrigAgility;

      iOrigAgility = piAgilityMod;
      piAgilityMod = piAgilityMod + points;

      if NOT bAbsolute
      {
         piAgilityMod = Bound(piAgilityMod,-piAgility,(MAXIMUM_STAT-piAgility));
      }

      if IsClass(self,&Player)
      {
         Send(self,@DrawAgility);
         Post(self,@DrawDefense);
      }

      return piAgilityMod - iOrigAgility;
   }

   AddMysticism(points = 0, bAbsolute = TRUE, scale_up_monster_mana = FALSE)
   "Returns signed change to agility (negative means decrease)"
   "If restore = TRUE, ignore the bounds check and add the amount anyway."
   {
      local iOrigMysticism;

      iOrigMysticism = piMysticismMod;
      piMysticismMod = piMysticismMod + points;

      if NOT bAbsolute
      {
         piMysticismMod = Bound(piMysticismMod,-piMysticism,(MAXIMUM_STAT-piMysticism));
      }

      if IsClass(self,&Player)
      {
         Send(self,@DrawMysticism);
         Send(self,@ComputeMaxMana);
      }
      if IsClass(self,&Monster)
         AND scale_up_monster_mana
      {
         piMana = (Send(self,@GetMana) * 
                  (100+Send(self,@GetMysticism)))/100;
         piMax_mana = (Send(self,@GetMaxMana) *
                      (100+Send(self,@GetMysticism)))/100;
      }

      return piMysticismMod - iOrigMysticism;
   }

   ZeroMods()
   "Should NOT be called before removing all potential stat-modifying things"
   {
      piMightMod = 0;
      piIntellectMod = 0;
      piMysticismMod = 0;
      piAgilityMod = 0;
      piStaminaMod = 0;
      piAimMod = 0;

      return;
   }

   GetHealth()
   {
      return piHealth/100;
   }

   GetExactHealth()
   {
      return piHealth;
   }

   GetMaxHealth()
   {
      return piMax_health;
   }

   GetBaseMaxHealth()
   {
      return piBase_max_health;
   }

   GetMight()
   {
      return bound((piMight + piMightMod),1,MAXIMUM_STAT);
   }

   GetIntellect()
   {
      return bound((piIntellect + piIntellectMod),1,MAXIMUM_STAT);
   }

   GetAgility()
   {
      return bound((piAgility + piAgilityMod),1,MAXIMUM_STAT);
   }

   GetAim()
   {
      return bound((piAim + piAimMod),1,MAXIMUM_STAT);
   }

   GetStamina()
   {
      return bound((piStamina + piStaminaMod),1,MAXIMUM_STAT);
   }

   GetMysticism()
   {
      return bound((piMysticism + piMysticismMod),1,MAXIMUM_STAT);
   }

   GetRawMight()
   {
      return bound(piMight,1,50);
   }

   GetRawIntellect()
   {
      return bound(piIntellect,1,50);
   }

   GetRawAgility()
   {
      return bound(piAgility,1,50);
   }

   GetRawAim()
   {
      return bound(piAim,1,50);
   }

   GetRawStamina()
   {
      return bound(piStamina,1,50);
   }

   GetRawMysticism()
   {
      return bound(piMysticism,1,50);
   }

   GainHealthNormal(amount = $, precision = FALSE)
   "Don't add beyond piMax_health"
   {
      local iOldhealth;

      if NOT precision
      {
         amount = amount*100;
      }

      iOldhealth = piHealth;

      if amount < 0
      {
         return;
      }

      if piHealth > piMax_health*100
      {
         return 0;
      }

      if NOT Send(self,@IsInCannotInteractMode)
      {
         pihealth = piHealth + amount;
         if piHealth > piMax_health*100
         {
            piHealth = piMax_health*100;
         }
      }

      Send(self,@NewHealth);

      return (piHealth - iOldhealth);
   }

   % Returns weapon used.
   GetWeapon()
   {
      local oWeapon;

      if IsClass(self,&Player)
      {
         oWeapon = Send(self,@LookupPlayerWeapon);
      }
      else
      {
         oWeapon = Send(self,@LookupMonsterWeapon);
      }
      
      % If there is no wielded melee weapon, then see if we
      % have a touch attack active.
      if oWeapon = $
      {
         % This will return $ if there's no Touch Attacks enchanting player.
         oWeapon = Send(self,@GetEnchantmentsByClass,
               #EnchClass=&TouchAttackSpell);
         if oWeapon <> $
         {
            % The spell object is the second element of the list. Get that.
            oWeapon = Nth(first(oWeapon),2);
         }
      }

      return oWeapon;
   }

   % Returns shield used.
   GetShield()
   {
      local oShield;

      if IsClass(self,&Player)
      {
         oShield = Send(self,@LookupPlayerShield);
      }
      else
      {
         oShield = Send(self,@LookupMonsterShield);
      }

      return oShield;
   }

   SetExactHealth(amount=$)
   {
      if amount <> $
      {
         piHealth = bound(amount,0,$);
      }
      
      return;
   }

   SetHealth(amount=$)
   {
      if amount <> $
      {
         piHealth = bound(amount*100,0,$);
      }

      Send(self,@DrawHealth);

      return;
   }

end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

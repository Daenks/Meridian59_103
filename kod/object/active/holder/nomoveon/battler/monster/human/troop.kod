% Meridian 59, Copyright 1994-2012 Andrew Kirmse and Chris Kirmse.
% All rights reserved.
%
% This software is distributed under a license that is described in
% the LICENSE file that accompanies it.
%
% Meridian is a registered trademark.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
FactionTroop is Human

constants:

   include blakston.khd

   HUMAN_TRANSLATION_Skin_MASK = 0xff0000
   HUMAN_TRANSLATION_Skin_MUL = 0x10000

resources:

   FactionTroop_name_rsc = "faction troop"

   FactionTroop_desc_rsc = \
   "This is a member of the local militia."

   FactionTroop_dead_name_rsc = "dead faction troop"

classvars:

   vrName = FactionTroop_name_rsc
   vrDesc = FactionTroop_desc_rsc
   vrDead_name = FactionTroop_dead_name_rsc

   viDefault_behavior = AI_FIGHT_NEWBIESAFE | AI_MOVE_REGROUP

   viColorTranslate1 = XLAT_TO_RED     % Shirt
   viColorTranslate2 = XLAT_TO_BLACK   % Pants


properties:

   piBaseLevel = 80
   piBaseDifficulty = 6

   viLevel = 80         % piBaseLevel
   viDifficulty = 4     % piBaseDifficulty

messages:

   Constructor()
   {
      Send(self,@SetHumanShirt,#translation=viColorTranslate1);
      Send(self,@SetHumanLegs,#translation=viColorTranslate2);
      Send(self,@SetShield);
      Send(self,@SetEquipment);
      
      propagate;
   }

   SetSkinColor()
   % Sets skin to one of the four skin colors.
   {
      local skin_color;
      skin_color = random(PT_BLUE_TO_SKIN1,PT_BLUE_TO_SKIN4);

      piBody_translations = piBody_translations & ~Human_TRANSLATION_SKIN_MASK;
      piBody_translations = piBody_translations | (skin_color * Human_TRANSLATION_SKIN_MUL);

      return;
   }

   SetEquipment()
   {
      local oEquipmentItem, iRandomNumber, iBonusModifier;

      iRandomNumber = random(1,100);
      if iRandomNumber <= 35
      {
         oEquipmentItem = create(&Longsword);
         iBonusModifier = 3;
      }
      else
      {
         if iRandomNumber <= 55
         {
            oEquipmentItem = create(&Axe);
            iBonusModifier = 2;
         }
         else
         {
            if iRandomNumber <= 65
            {
               oEquipmentItem = create(&Hammer);
               iBonusModifier = 2;
            }
            else
            {
               if iRandomNumber <= 75
               {
                  oEquipmentItem = create(&Mace);
                  iBonusModifier = 1;
               }
               else
               {
                  if iRandomNumber <= 80
                  {
                     oEquipmentItem = create(&ShortSword);
                     iBonusModifier = 1;
                  }
                  else
                  {   
                     if iRandomNumber <= 85
                     {
                        oEquipmentItem = create(&Scimitar);
                        iBonusModifier = 4;
                     }
                     else
                     {
                        if iRandomNumber <= 90
                        {
                          oEquipmentItem = create(&BattleBow);
                          poArrow = create(&NeruditeArrow);
                          iBonusModifier = 5;
                        }
                        else
                        {
                           oEquipmentItem = create(&LongBow);
                           poArrow = create(&NeruditeArrow);
                           iBonusModifier = 4;
                        }
                     }   
                  }  
               }
            }
         }
      }
                  
      viDifficulty = piBaseDifficulty + iBonusModifier;
      Send(self,@AddEquipmentObject,#what=oEquipmentItem);

      iRandomNumber = random(1,100);

      if iRandomNumber <= 35
      {
         oEquipmentItem = create(&LeatherArmor);
         iBonusModifier = 20;
      }
      else
      {
         if iRandomNumber <= 70
         {
            oEquipmentItem = create(&ChainArmor);
            iBonusModifier = 50;
         }
         else
         {
           if iRandomNumber <= 85
           {
              oEquipmentItem = create(&ScaleArmor);
              iBonusModifier = 75;
           }
           else
           {
             oEquipmentItem = create(&PlateArmor);
             iBonusModifier = 100;
           }
        }
     }

      viLevel = piBaseLevel + iBonusModifier;
      Send(self,@SetHumanArmor,#NewArmor=oEquipmentItem);

      % Gauntlets?
      iRandomNumber = random(1,100);
      if iRandomNumber < 20
      {
         oEquipmentItem = create(&Gauntlet);
         plUsing = Cons(oEquipmentItem,plUsing);
         viDifficulty = viDifficulty +1;
         viLevel = viLevel + 20;
         if viGender = GENDER_MALE
         {
            prRight_arm = Human_rightarm_gauntlet_male;
            prLeft_arm = Human_leftarm_gauntlet_male;
         }
         else
         {
            prRight_arm = Human_rightarm_gauntlet_female;
            prLeft_arm = Human_leftarm_gauntlet_female;
         }
      }

      return;
   }

   SetShield()
   {
      local oEquipmentItem;

      oEquipmentItem = create(vcShieldClass,#color1=viShieldColor1,#color2=viShieldColor2,
                              #shape=viShieldShape);
      if viInsignia <> $
      {
         Send(oEquipmentItem,@ChangeGuildInsignia,#insignia=viInsignia);
      }

      Send(self,@AddEquipmentObject,#what=oEquipmentItem);
      
      return;
   }

   % Next two messages affect the defense messages.
   GetParryAbility(stroke_obj=$)
   {
      if (stroke_obj <> $) and not Send(stroke_obj,@CanParry)
      {
         return 0;
      }
      
      return (viDifficulty*10)/2;
   }

   GetBlockAbility(stroke_obj=$)
   {
      if (stroke_obj <> $) and not Send(stroke_obj,@CanBlock)
      {
         return 0;
      }
      
      return (viDifficulty*10);
   }
   % Returns weapon used.

   GetWeapon()
   {
      local oWeapon;

      oWeapon = Send(self,@LookupPlayerWeapon);
      % If there is no wielded melee weapon, then see if we
      % have a touch attack active.
      if oWeapon = $
      {
         % This will return $ if there's no Touch Attacks enchanting player.
         oWeapon = Send(self,@GetEnchantmentsByClass,
               #EnchClass=&TouchAttackSpell);
         if oWeapon <> $
         {
            % The spell object is the second element of the list. Get that.
            oWeapon = Nth(first(oWeapon),2);
         }
      }

      return oWeapon;
   }

   % Returns wielded Melee/Ranged weapon.
   LookupPlayerWeapon()
   {
      local i;

      for i in plUsing
      {
         if IsClass(i,&Weapon)
         {
            return i;
         }
      }

      return $;
   }

   GetDamageType()
   {
      local oWeapon;

      oWeapon = Send(self,@GetWeapon);

      if oWeapon <> $
      {
         return Send(oWeapon,@GetAttackType);
      }

      propagate;
   }

   MonsterAttack(what = $)
   "Add in any attack animation calls."
   {
      local oWeapon;

      oWeapon = Send(self,@GetWeapon);

      if oWeapon <> $
         AND IsClass(oWeapon,&Bow)
      {
         Send(oWeapon,@WeaponAttack);
      }
      else
      {
         Send(self,@DoSlash);
      }

      return;
   }
   
   DoSlash()
   {
      piAnimation = PANM_WEAPON_ATTACK;
      Send(poOwner,@SomethingChanged,#what=self);
      piAnimation = ANIM_NONE;

      return;
   }

   DoBowFire()
   {
      piAnimation = PANM_BOW_FIRE;
      Send(poOwner,@SomethingChanged,#what=self);
      piAnimation = PANM_NONE;

      Send(poOwner,@SomethingShot,#who=self,#target=poTarget,
            #projectile=poArrow);

      return;
   }

   GetAttackRange()
   {
      local iWeapon;

      iWeapon = Send(Self,@GetWeapon);

      if iWeapon <> $
      {
         return Send(iWeapon,@GetRange);
      }

      propagate;
   }

   SendMoveAnimation()
   {
      local iBody_xlat;

      iBody_xlat = (piBody_translations & FACTIONTROOP_TRANSLATION_BODY_MASK)
                        / FACTIONTROOP_TRANSLATION_BODY_MUL;
      if iBody_xlat <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION,1,iBody_xlat);
      }

      % use standing torso
      AddPacket(1, ANIMATE_NONE,2,1);
      
      return;
   }

   SendAnimation()
   {
      local iBody_xlat;
      
      iBody_xlat = (piBody_translations & FACTIONTROOP_TRANSLATION_BODY_MASK)
                        / FACTIONTROOP_TRANSLATION_BODY_MUL;
      if (piBody_translations & FACTIONTROOP_TRANSLATION_BODY_MASK) <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION,1,iBody_xlat);
      }

      %% all new data
      if piAnimation = PANM_WEAPON_ATTACK
      {
         AddPacket(1,ANIMATE_ONCE,4,300,2,2,2,4,2,1);
         
         return;
      }
      else
      {
         if piAnimation = PANM_BOW_FIRE
         {
            AddPacket(1,ANIMATE_ONCE, 4,1200, 2,5, 2,5, 2,1);

            return;
         }
      }

      propagate;
   }

   SendMoveOverlays()
   {
      local i,iOverlays,hotspot,iLeft_group,iRight_group,iSkin_xlat,
            iArms_xlat,iLegs_xlat;

      % Player has 7 standard overlays: right arm, left arm, legs, head, eyes, 
      % mouth, nose
      iOverlays = 7;
      
      if poHair_remove = $
      {
         iOverlays = iOverlays + 1;
      }

      iLeft_group = 1;
      iRight_group = 1;

      for i in plOverlays
      {
         iOverlays = iOverlays + Send(i,@GetNumberOverlays);  %bows can have more than 1.
         hotspot = Send(i,@GetOverlayHotspot);
         if hotspot = HS_RIGHT_WEAPON
         {
            iRight_group = 17;
         }
         else
         {
            if hotspot = HS_LEFT_WEAPON or hotspot = HS_BOTTOM_BOW
            % it's really a shield, not weapon
            {
               iLeft_group = 7;
            }
         }
      }
      
      AddPacket(1,iOverlays);
      AddPacket(4,prLeft_arm,1,HS_LEFT_HAND);
      
      iArms_xlat = (piBody_translations2 & FACTIONTROOP_TRANSLATION2_ARMS_MASK)
                        / FACTIONTROOP_TRANSLATION2_ARMS_MUL;
      if iArms_xlat <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION,1,iArms_xlat);
      }
      
      if iLeft_group = 1
      {
         AddPacket(1,ANIMATE_CYCLE,4,200,2,2,2,3);
      }
      else
      {
         AddPacket(1,ANIMATE_NONE,2,iLeft_group); 
      }

      AddPacket(4,prRight_arm,1,HS_RIGHT_HAND);
      if iArms_xlat <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION,1,iArms_xlat);
      }
      
      if iRight_group = 1
      {
         Addpacket(1,ANIMATE_CYCLE,4,200,2,2,2,3);
      }
      else
      {
         AddPacket(1,ANIMATE_NONE,2,iRight_group); 
      }

      AddPacket(4,prLegs,1,HS_LEGS);
      iLegs_xlat = (piBody_translations & FACTIONTROOP_TRANSLATION_LEGS_MASK)
                        / FACTIONTROOP_TRANSLATION_LEGS_MUL;
      if iLegs_xlat <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION,1,iLegs_xlat);
      }
      
      AddPacket(1,ANIMATE_CYCLE,4,100,2,2,2,5);

      iSkin_xlat = (piBody_translations & FACTIONTROOP_TRANSLATION_Skin_MASK)
                        / FACTIONTROOP_TRANSLATION_SKIN_MUL;

      AddPacket(4,prHead,1,HS_HEAD,1,ANIMATE_TRANSLATION,1,iSkin_xlat);
      Addpacket(1,ANIMATE_NONE,2,1);        
      
      AddPacket(4,prMouth,1,HS_MOUTH,1,ANIMATE_TRANSLATION,1,iSkin_xlat,1,ANIMATE_NONE,2,NO_ACTION);
      AddPacket(4,prEyes,1,HS_EYES,1,ANIMATE_TRANSLATION,1,iSkin_xlat,1,ANIMATE_NONE,2,NO_ACTION);
      AddPacket(4,prNose,1,HS_NOSE,1,ANIMATE_TRANSLATION,1,iSkin_xlat,1,ANIMATE_NONE,2,1);

      if poHair_remove = $
      {  
         AddPacket(4,prToupee,1,HS_TOUPEE,1,ANIMATE_TRANSLATION,1,
                   (piBody_translations2 & FACTIONTROOP_TRANSLATION2_HAIR_MASK)
                     / FACTIONTROOP_TRANSLATION2_HAIR_MUL);
         AddPacket(1,ANIMATE_NONE,2,1); 
      }

      for i in plOverlays
      {
         Send(i,@SendOverlayInformation,#iAnimation = $);
      }
      return;
   }

   SendOverlays()
   {
      local i,iOverlays,hotspot,iLeft_group,iRight_group,iSkin_xlat,
            iArms_xlat, iLegs_xlat;

      % Send overlay bitmap info to user.  

      % Player has 7 standard overlays: right arm, left arm, legs, head, eyes, mouth, nose
      iOverlays = 7;
      
      if poHair_remove = $
      {
         iOverlays = iOverlays + 1;
      }
      
      % Overlay info -- display correct group for animation & action

      iLeft_group = 1;
      iRight_group = 1;

      for i in plOverlays
      {
         iOverlays = iOverlays + Send(i,@GetNumberOverlays,#iAnimation=piAnimation);  %bows can have more than 1.
         hotspot = Send(i,@GetOverlayHotspot);
         if hotspot = HS_RIGHT_WEAPON
         {
            iRight_group = 17;
         }
         else
         {
            if hotspot = HS_LEFT_WEAPON or hotspot = HS_BOTTOM_BOW
            % it's really a shield, not weapon 
            {
               iLeft_group = 7;
            }
         }
      }

      AddPacket(1, iOverlays);
      iArms_xlat = (piBody_translations2 & FACTIONTROOP_TRANSLATION2_ARMS_MASK)
                        / FACTIONTROOP_TRANSLATION2_ARMS_MUL;

      AddPacket(4,prLeft_arm,1,HS_LEFT_HAND);
      if iArms_Xlat <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION,1,iArms_xlat);
      }
      
      if piAnimation = ANIM_CAST
      {
         AddPacket(1,ANIMATE_ONCE,4,300,2,8,2,8,2,iLeft_group);
      }
      else
      {
         if piAnimation = PANM_WEAPON_ATTACK
         {
            AddPacket(1,ANIMATE_ONCE,4,300,2,4,2,6,2,iLeft_group);
         }
         else
         {
            if piAnimation = PANM_BOW_FIRE
            {
               AddPacket(1,ANIMATE_ONCE, 4,1200, 2,9, 2,9, 2,iLeft_group);
            }
            else
            {
               AddPacket(1,ANIMATE_NONE,2,iLeft_group);
            }
         }
      }

      AddPacket(4,prRight_arm,1,HS_RIGHT_HAND);
      if iArms_xlat <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION,1,iArms_xlat);
      }

      if piAnimation = ANIM_NONE
      {    
         AddPacket(1,ANIMATE_NONE,2,iRight_group); 
      }

      if piAnimation = ANIM_CAST
      {
         AddPacket(1,ANIMATE_ONCE,4,300,2,11,2,11,2,iRight_group);
      }

      if piAnimation = PANM_WEAPON_ATTACK
      {
         AddPacket(1,ANIMATE_ONCE,4,300,2,4,2,6,2,17);
      }

      if piAnimation = PANM_BOW_FIRE
      {
         AddPacket(1,ANIMATE_ONCE, 4,600, 2,15, 2,16, 2,iRight_group);
      }

      AddPacket(4,prLegs,1,HS_LEGS);
      iLegs_xlat = (piBody_translations & FACTIONTROOP_TRANSLATION_LEGS_MASK)
                        / FACTIONTROOP_TRANSLATION_LEGS_MUL;
      if iLegs_xlat <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION,1,iLegs_xlat);
      }
      
      if piAnimation = PANM_WEAPON_ATTACK
      {
         AddPacket(1,ANIMATE_ONCE,4,900,2,6,2,6,2,1);
      }
      else
      {
         if piAnimation = PANM_BOW_FIRE
         {
            AddPacket(1,ANIMATE_ONCE, 4,1200, 2,7, 2,7, 2,1);
         }
         else
         {
            AddPacket(1,ANIMATE_NONE,2,1);
         }
      }
  
      iSkin_xlat = (piBody_translations & FACTIONTROOP_TRANSLATION_Skin_MASK)
                        / FACTIONTROOP_TRANSLATION_Skin_MUL;
      AddPacket(4,prHead,1,HS_HEAD,1,ANIMATE_TRANSLATION,1,iSkin_xlat);
      Addpacket(1,ANIMATE_NONE,2,1); 
      
      AddPacket(4,prMouth,1,HS_MOUTH,1,ANIMATE_TRANSLATION,1,iSkin_xlat,1,ANIMATE_NONE,2,NO_ACTION);
      AddPacket(4,prEyes,1,HS_EYES,1,ANIMATE_TRANSLATION,1,iSkin_xlat,1,ANIMATE_NONE,2,NO_ACTION);
      AddPacket(4,prNose,1,HS_NOSE,1,ANIMATE_TRANSLATION,1,iSkin_xlat,1,ANIMATE_NONE,2,1);
      
      if poHair_remove = $
      {  
         AddPacket(4,prToupee,1,HS_TOUPEE,1,ANIMATE_TRANSLATION,
                   1,(piBody_translations2 & FACTIONTROOP_TRANSLATION2_HAIR_MASK)
                     / FACTIONTROOP_TRANSLATION2_HAIR_MUL);
         AddPacket(1,ANIMATE_NONE,2,1); 
      }
      
      for i in plOverlays
      {
         Send(i,@SendOverlayInformation,#iAnimation=piAnimation);
      }
      
      return;
   }

   SetTroopArmor(NewArmor = $)
   % Sets the troop's armor icon.
   {
      vrIcon = Send(NewArmor,@GetShirtIcon,#who=self);
      plUsing = cons(NewArmor, plUsing);

      if poOwner <> $
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   SetTroopShirt(translation = 0)
   % Sets troop shirt color.  Send the xlat value for color, this procedure calculates skin color and figures
   %  the two color xlat for you.
   {
      local iShirtXlat, iSkinColor;
      
      iSkinColor = (piBody_translations & FACTIONTROOP_TRANSLATION_SKIN_MASK)/FACTIONTROOP_TRANSLATION_SKIN_MUL;
      iSkinColor = Send(self,@ConvertSkinColorToXLAT,#Skin_color=iSkinColor);
      iShirtXlat = Send(SYS,@EncodeTwoColorXLAT,#color1=translation,#color2=iSkinColor);

      piBody_translations2 = piBody_translations2 & ~FACTIONTROOP_TRANSLATION2_ARMS_MASK;
      piBody_translations2 = piBody_translations2 | (iShirtXlat * FACTIONTROOP_TRANSLATION2_ARMS_MUL);

      piBody_translations = piBody_translations & ~FACTIONTROOP_TRANSLATION_BODY_MASK;
      piBody_translations = piBody_translations | (iShirtXlat * FACTIONTROOP_TRANSLATION_BODY_MUL);

      if poOwner <> $
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   SetTroopLegs(translation = 0)
   % Sets troop leg color.  Send the xlat value for color, this procedure calculates skin color and figures
   %  the two color xlat for you.
   {
      local iPantsXlat, iSkinColor;
      
      iSkinColor = (piBody_translations & FACTIONTROOP_TRANSLATION_SKIN_MASK)/FACTIONTROOP_TRANSLATION_SKIN_MUL;
      iSkinColor = Send(self,@ConvertSkinColorToXLAT,#Skin_color=iSkinColor);

      % A hack for non-standard skin colors with the "special" pants colors.
      if translation >= XLAT_TO_DGREEN
         AND (iSkinColor < XLAT_TO_SKIN1
              OR iSkinColor > XLAT_TO_SKIN4)
      {
         iSkinColor = XLAT_TO_SKIN4;
      }
      
      iPantsXlat = Send(SYS,@EncodeTwoColorXLAT,#color1=translation,#color2=iSkinColor);

      piBody_translations = piBody_translations & ~FACTIONTROOP_TRANSLATION_LEGS_MASK;
      piBody_translations = piBody_translations | (iPantsXlat * FACTIONTROOP_TRANSLATION_LEGS_MUL);

      if poOwner <> $
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   AddEquipmentObject(what = $)
   % Adds Overlay to list if not duplicated.
   {
      local i;

      for i in plOverlays
      {
         if i = what
         {
            return;
         }
      }
      if IsClass(what,&Bow)
      {
         for i in plUsing
         {
            if IsClass(i,&SoldierShield)
            {
               Send(i,@SlingOnBack,#report=FALSE);

               break;
            }
         }
      }
      Send(self,@NewHold,#what=what);
      plUsing = Cons(what,plUsing);
      plOverlays = Cons(what,plOverlays);

      if poOwner <> $
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   % Override from monster superclass
   % We drop some of our carried items when we die.
   CreateTreasure(who = $, corpse = $)
   {
      local oUsedItem, oItemAtt;

      oItemAtt = Send(SYS,@FindItemAttByNum,#num=IA_CORPSEPOINTER);

      for oUsedItem in plUsing
      {
         % Only a percentage chance to drop each item.  Too much stuff otherwise.
         % Don't drop the shield!  It's a quest/special item!
         if (Random(1,100) <= EQUIPMENT_DROP_PERCENT)
            AND (NOT IsClass(oUsedItem,vcShieldClass))
            AND NOT pbIllusion
         {
            if (oItemAtt <> $) AND Send(oItemAtt,@ReqAddToItem,#oItem=oUsedItem)
            {
               Send(oItemAtt,@AddToItem,#oItem=oUsedItem,#state1=corpse);
            }

            Send(poOwner,@NewHold,#what=oUsedItem,
                  #new_row=piRow,#new_col=piCol,
                  #fine_row=piFine_row,#fine_col=piFine_col);
         }
         else
         {
            Send(oUsedItem,@Delete);
         }
      }

      plUsing = $;

      % Don't propagate.  We do everything here.
      return;
   }

   % Override from monster superclass
   CreateDeadBody(killer=$)
   {
      return Create(&DeadBody,
         #victim=self,
         #killer=killer,
         #PlayerBodyOverlay=vrDead_Legs,
         #BodyTranslation=(piBody_translations & FACTIONTROOP_TRANSLATION_BODY_MASK)/FACTIONTROOP_TRANSLATION_BODY_MUL,
         #LegsTranslation=(piBody_translations & FACTIONTROOP_TRANSLATION_LEGS_MASK)/FACTIONTROOP_TRANSLATION_LEGS_MUL);
   }

   ConvertskincolortoXLAT(Skin_color = 0)
   % Calculates the hand xlat from the blue to skin color translate.
   {
      % since the face translates use a single translate and the body uses
      %     a double translate which has less color values available,
      %     here we map the face translate to a similar body translate.
      if skin_color = PT_BLUE_TO_SKIN1  { return XLAT_TO_SKIN1; }
      if skin_color = PT_BLUE_TO_SKIN2  { return XLAT_TO_SKIN1; }
      if skin_color = PT_BLUE_TO_SKIN3  { return XLAT_TO_SKIN2; }
      if skin_color = PT_BLUE_TO_SKIN4  { return XLAT_TO_SKIN4; }

      if skin_color = PT_BLUE_TO_GREEN  { return XLAT_TO_SKIN1; }
      if skin_color = PT_BLUE_TO_YELLOW  { return XLAT_TO_SKIN1; }
      if skin_color = PT_BLUE_TO_GRAY  { return XLAT_TO_GRAY; }
      if skin_color = PT_BLUE_TO_ASHEN  { return XLAT_TO_GRAY; }
      if skin_color = PT_BLEND25YELLOW  { return XLAT_TO_SKY; }      
      if skin_color = PT_BLEND25RED  { return XLAT_TO_BLUE; }
      if skin_color = PT_BLUE_TO_LBLUE  { return XLAT_TO_SKY; }

      if Send(SYS,@IsTwoColorXLAT,#Xlat=skin_color)
      {
         return Send(SYS,@DecodeSecondaryColor,#Xlat=skin_color);
      }

      return XLAT_TO_SKIN1;   %% Skin color 3 uses 2nd xlat too.
   }

   IsAlly(target = $, regroup = FALSE)
   {
      local iFaction;
      if isClass(target,getClass(self))
      {
         return TRUE;
      }
      
      if isClass(target,&Player)
      {
         iFaction = Send(target,@GetFaction);
         if (not regroup) and (iFaction = FACTION_NEUTRAL)
         {
            return TRUE;
         }
         
         if iFaction = viFaction
         {
            return TRUE;
         }
         else
         {
            return FALSE;
         }
      }
      
      propagate;
   }

   SpecialHatredBehavior(what=$)
   {
      local iFaction;
      
      if isClass(what,&User) or isClass(what,&FactionTroop)
      {
         iFaction=Send(what,@GetFaction);
         if iFaction = viFaction
         {
            return -30;
         }
         
         if (iFaction <> FACTION_NEUTRAL) and (iFaction <> viFaction)
         {
            return 30;
         }
      }
      
      return 0;
   }

   Delete()
   {
      local i, oUsedItem;
      
      for oUsedItem in plUsing
      {
         Send(oUsedItem,@delete);
      }
        
      if poArrow<>$
      {
        Send(poArrow,@Delete);
      }
      poArrow = $;
      
      plUsing = $;
      plOverlays = $;

      propagate;
   }

   CanMorphTo()
   {
      return FALSE;
   }

   GetEquippedItems()
   {
      return plUsing;
   }

   % Reproduce the Player overlay messages here, so we can use items such
   % as bows/slung shields, lutes etc. These are generally called from the
   % items themselves, as there is simpler/faster code for adding overlays
   % already in this file.

   SetOverlay(what = $)
   "Adds <what> to plOverlays, and tells everyone we changed."
   {
      Send(self,@AddOverlayObject,#what=what);
      if poOwner <> $
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   RemoveOverlay(what = $)
   "Removes <what> from plOverlays if it's in there, and "
   "tells everyone we changed."
   {
      Send(self,@RemoveOverlayObject,#what=what);
      if poOwner <> $
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   AddOverlayObject(what = $)
   "Adds <what> to plOverlays, so we can keep track of whom to "
   "call about overlays"
   {
      local i;

      for i in plOverlays
      {
         if i = what
         {
            return;
         }
      }

      plOverlays = Cons(what,plOverlays);

      return;
   }

   RemoveOverlayObject(what = $)
   "Removes <what> from plOverlays if it's in there."
   {
      local i;

      for i in plOverlays
      {
         if i = what
         {
            plOverlays = DelListElem(plOverlays,what);

            return;
         }
      }

      return;
   }

   ChangeWindowOverlay()
   {
      return;
   }

   RemoveWindowOverlay()
   {
      return;
   }

end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Meridian 59, Copyright 1994-2012 Andrew Kirmse and Chris Kirmse.
% All rights reserved.
%
% This software is distributed under a license that is described in
% the LICENSE file that accompanies it.
%
% Meridian is a registered trademark.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
FogCloud is PassiveObject

constants:

   include blakston.khd

resources:

   fogcloud_name_rsc = "thick fog"
   fogcloud_icon_rsc = poisoncl.bgf
   fogcloud_desc_rsc = "You choke just looking at the thick putrid fog."

classvars:

   vrName = fogcloud_name_rsc
   vrIcon = fogcloud_icon_rsc

   viObject_flags = LOOK_NO | DRAWFX_TRANSLUCENT_50
   vrdesc = fogcloud_desc_rsc

properties:

   poCaster = $
   ptExpire = $
   vbSummoned = TRUE

   % The wallelement carries all relevant information in its seed. This allows 
   % the element to spawn additional elements that inherit their behavior from
   % the parent. plSeed has the following structure:
   % plSeed = [1caster,2spellpower,3duration,4charges,5speed,6direction,7step,8noise,9twirl]
   plSeed = $

   % Timer that spawns the next element upon expiration.
   ptSeed = $

messages:

   Constructor(seed=$)
   {
      plSeed = seed;

      poCaster = First(seed);

      ptExpire = CreateTimer(self,@Expire,Nth(seed,3)+random(0,1000));

      if IsClass(First(seed),&User)
      {
         vbSummoned = TRUE;
      }

      % If we have a charge left, create a new element after an amount of ms
      % specified in speed.
      if Nth(plSeed,4) > 0 
      {
         ptSeed = CreateTimer(self,@SpawnNextElement,Nth(seed,5));
      }

      propagate;
   }
   
   Constructed()
   {
      %% at this point, the wall should have already been created.
      %% therefore, it should be safe to delete it.
      post(self,@ArenaCheck);

      propagate;
   }

   SpawnNextElement()
   {
      local lSeed, iRow, iCol, iFine_Row, iFine_Col, iXStep, iYStep, oElement, oRoom;

      ptSeed = $;
      oRoom = Send(self,@GetOwner);

      % Inherit the properties of the old element but remove one charge.
      lSeed = plSeed;
      setnth(lSeed,4,Nth(plSeed,4)-1);
      
      % If 'twirl' is enabled, shift the direction by 45 degrees every 'twirl' charges.
      if Nth(lSeed,9) AND (Nth(plSeed,4) MOD Nth(lSeed,9)) = 0
      {
         setnth(lSeed,6,(Nth(plSeed,6)+1) MOD 8);
      }

      % First, let's interpret the seed's direction. If the direction is 0 or
      % invalid, let's assume it's north.
      iXStep = 0;
      iYStep = -1;

      % NorthEast
      if Nth(lSeed,6) = 1
      {
         iXStep = 1;
         iYStep = -1;
      }

      % East
      if Nth(lSeed,6) = 2
      {
         iXStep = 1;
         iYStep = 0;
      }

      % SouthEast
      if Nth(lSeed,6) = 3
      {
         iXStep = 1;
         iYStep = 1;
      }

      % South
      if Nth(lSeed,6) = 4
      {
         iXStep = 0;
         iYStep = 1;
      }

      % SouthWest
      if Nth(lSeed,6) = 5
      {
         iXStep = -1;
         iYStep= 1;
      }

      % West
      if Nth(lSeed,6) = 6
      {
         iXStep = -1;
         iYStep = 0;
      }

      % NorthWest
      if Nth(lSeed,6) = 7
      {
         iXStep = -1;
         iYStep = -1;
      }

      % Figure out where to spawn the next element based on our current
      % position, our direction, our stepsize and the randomization factor.
      iRow = Send(self,@GetRow) + iYStep * Nth(lSeed,7);
      iCol = Send(self,@GetCol) + iXStep * Nth(lSeed,7);
      
      iFine_Row = Send(self,@GetFineRow) + random(-Nth(lSeed,8),Nth(lSeed,8));
      if iFine_Row < 0
      {
         iFine_Row = iFine_Row + 64;
         iRow = iRow - 1;
      }
      if iFine_Row > 63
      {
         iFine_Row = iFine_Row - 64;
         iRow = iRow + 1;
      }

      iFine_Col = Send(self,@GetFineCol) + random(-Nth(lSeed,8),Nth(lSeed,8));
      if iFine_Col < 0
      {
         iFine_Col = iFine_Col + 64;
         iCol = iCol - 1;
      }
      if iFine_Col > 63
      {
         iFine_Col = iFine_Col - 64;
         iCol = iCol + 1;
      }
      
      oElement = Create(GetClass(self),#seed=lSeed);
      Send(oRoom,@NewHold,#what=oElement,#new_row=iRow,#new_col=iCol,
         #fine_row=iFine_Row,#fine_col=iFine_Col);

      return;
   }

   ArenaCheck()
   {
      if send(poOwner,@IsArena)
      and not send(poOwner,@InPlay,#what=self,#bNonPlayerOkay = TRUE)
      {	 
	      post(self,@Delete);
      }
      return;
   }

   Expire()
   {
      ptExpire = $;
      Send(self,@Delete);
      return;
   }

   Delete()
   {
      if ptExpire <> $
      {
         DeleteTimer(ptExpire);
         ptExpire = $;
      }

      if ptSeed <> $
      {
         DeleteTimer(ptSeed);
         ptSeed = $;
      }

      propagate;
   }

   ReqNewOwner(what = $)
   {
      return IsClass(what,&Room);
   }

   NewOwner(what = $)
   {
      if IsClass(what,&GuildHall) and
         (send(what,@InFoyer,#who=poCaster) <> send(what,@InFoyer,#who=self))
      {
         post(self,@delete);
      }
      propagate;
   }

   SendAnimation()
   {
      AddPacket(1, ANIMATE_CYCLE, 4, random(280,300), 2, 1, 2, 5);
      return;
   }


end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

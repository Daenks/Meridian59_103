% Meridian 59, Copyright 1994-2012 Andrew Kirmse and Chris Kirmse.
% All rights reserved.
%
% This software is distributed under a license that is described in
% the LICENSE file that accompanies it.
%
% Meridian is a registered trademark.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
LightningStrike is Spell

constants:
   include blakston.khd

   % What change in elevation will stop lightning strike?
   ELEVATION_RISE_MAX = 15

resources:

   lightning_strike_name_rsc = "lightning strike"
   lightning_strike_icon_rsc = lightnin.bgf
   lightning_strike_desc_rsc = \
     "Lands a wild teleporting strike on your target's back. "
     "Repeated use of this spell can exhaust even the strongest mage."

   lightning_strike_max_cooldowns = \
      "You need to rest for a moment before striking again."
   lightning_strike_not_here = \
      "You can't strike here!"
   lightning_strike_too_short = \
      "You don't have enough power to strike even a step!"
   lightning_strike_dashed = \
      "You strike %i steps!"
   lightning_strike_no_space = \
      "Your target doesn't have enough space behind them!"
   lightning_strike_no_longer = \
      "You are exhausted, and cannot strike again for %i seconds."
   lightning_strike_can_do_now = \
      "You feel that you can strike again."
   lightning_strike_sound = fbolt.wav

classvars:

   vrName = lightning_strike_name_rsc
   vrIcon = lightning_strike_icon_rsc
   vrDesc = lightning_strike_desc_rsc
   vrSucceed_wav = lightning_strike_sound

   viCast_time = 0

   viSpell_num = SID_LIGHTNING_STRIKE
   viSpell_level = 6
   viSchool = SS_FAREN
   viMana = 8
   viSpellExertion = 10
   viChance_To_Increase = 15
   viMeditate_ratio = 20

properties:

   % This spell keeps track of player cooldowns.
   plCooldowns = $

   % A player can use the spell this many times in a row.
   piMaxUses = 2

   % It takes this long for one cooldown to lift.
   piCooldownTime = 15000

messages:

   ResetReagents()
   {
      plReagents = $;

      return;
   }

   GetNumSpellTargets()
   {
      return 1;
   }

   CanPayCosts(who=$,lTargets=$,bItemCast=FALSE)
   {
      local oRoom;
      
      oRoom = Send(who,@GetOwner);

      if oRoom <> $
         AND IsClass(oRoom,&Room)
         AND Send(oRoom,@CheckRoomFlag,#flag=ROOM_NO_COMBAT)
      {
         Send(who,@MsgSendUser,#message_rsc=lightning_strike_not_here);
         return FALSE;
      }

      % If you're at or beyond max cooldowns, can't use the spell.
      if Send(self,@GetCooldown,#who=who) >= piMaxUses
      {
         Send(who,@MsgSendUser,#message_rsc=lightning_strike_max_cooldowns);
         return FALSE;
      }

      propagate;
   }

   CastSpell(who = $, lTargets = $, iSpellPower=0)
   {                   
      local oRoom, iRow, iCol, iFineRow, iFineCol, iDist,
                   iNewRow, iNewCol, iNewFineRow, iNewFineCol,
                   iRowPercentage, iColPercentage, iRowSign, iColSign,
                   iRowDist, iColDist, oRoomData, iSteps,
                   iRowSuccess, iColSuccess, iFineRowSuccess, iFineColSuccess,
                   oElement, iRot, iCurDist, oTarget, iTargetAngle,
                   iStartHeight, iNextHeight;

      oTarget = First(lTargets);
      
      if oTarget = $
      {
         return FALSE;
      }

      oRoom = Send(who,@GetOwner);
      if oRoom = $
      {
         return FALSE;
      }
      oRoomData = Send(oRoom,@GetRoomData);

      % 1 full unit behind target
      iDist = 64;

      % This spell calculates your intended destination without trigonometry.
      % The diff you travel is split into percentages of X and Y distance.
      % The spell then attempts to teleport you by checking with
      % Line of Sight.
      
      iCol = Send(oTarget,@GetCol);
      iRow = Send(oTarget,@GetRow);
      iFineCol = Send(oTarget,@GetFineCol);
      iFineRow = Send(oTarget,@GetFineRow);
      iTargetAngle = Send(oTarget,@GetAngle);
      iRot = iTargetAngle + 2050;
      
      iStartHeight = GetHeight(oRoomData,iRow,iCol,iFineRow,iFineCol);

      if iRot > 4100
      {
         iRot = iRot - 4100;
      }

      iColPercentage = 100;
      iRowPercentage = 0;
      iColSign = 1;
      iRowSign = 1;
      
      % iRot 0 - 4100
      
      if iRot >= 0
         AND iRot <= 1025
      {
         iColPercentage = 100 - (100*iRot)/1025;
         iRowPercentage = (100*iRot)/1025;
         iColSign = 1;
         iRowSign = 1;
      }
      
      if iRot > 1025
         AND iRot <= 2050
      {
         iColPercentage = (100*(iRot-1025))/1025;
         iRowPercentage = 100 - (100*(iRot-1025))/1025;
         iColSign = -1;
         iRowSign = 1;
      }
      
      if iRot > 2050
         AND iRot <= 3175
      {
         iColPercentage = 100 - (100*(iRot-2050))/1025;
         iRowPercentage = (100*(iRot-2050))/1025;
         iColSign = -1;
         iRowSign = -1;
      }
      
      if iRot > 3175
         AND iRot < 4100
      {
         iColPercentage = (100*(iRot-3175))/1025;
         iRowPercentage = 100 - (100*(iRot-3175))/1025;
         iColSign = 1;
         iRowSign = -1;
      }

      iSteps = 0;
      iCurDist = 0;
      iColSuccess = iCol;
      iRowSuccess = iRow;
      iFineColSuccess = iFineCol;
      iFineRowSuccess = iFineRow;
      
      while iCurDist <= iDist
      {
         iColDist = ((FINENESS*iColPercentage)/100)*iColSign;
         iRowDist = ((FINENESS*iRowPercentage)/100)*iRowSign;

         iNewFineCol = iFineColSuccess + iColDist;
         iNewFineRow = iFineRowSuccess + iRowDist;
         
         iNewCol = iColSuccess;
         if iNewFineCol > 63
         {
            iNewCol = iNewCol + 1;
            iNewFineCol = iNewFineCol - FINENESS;
         }
         
         iNewRow = iRowSuccess;
         if iNewFineRow > 63
         {
            iNewRow = iNewRow + 1;
            iNewFineRow = iNewFineRow - FINENESS;
         }

         if Send(self,@LineOfSight,#oRoomData=oRoomData,
                                #row_start=iRowSuccess,
                                #col_start=iColSuccess,
                                #fine_row_start=iFineRowSuccess,
                                #fine_col_start=iFineColSuccess,
                                #row_end=iNewRow,
                                #col_end=iNewCol,
                                #fine_row_end=iNewFineRow,
                                #fine_col_end=iNewFineCol)
            AND GetHeight(oRoomData,iNewRow,iNewCol,iNewFineRow,iNewFineCol) <=
                   iStartHeight + ELEVATION_RISE_MAX
         {
            oElement = Create(&WallOfLightning,#MaxDamage=(iSpellPower+1)/4,#Caster=who,
                        #duration=800,#bMS=TRUE);
            Send(oRoom,@NewHold,#what=oElement,
                 #new_row=Send(who,@GetRow),#new_col=Send(who,@GetCol),
                 #fine_row=Send(who,@GetFineRow),#fine_col=Send(who,@GetFineCol));

            oElement = Create(&WallOfLightning,#MaxDamage=(iSpellPower+1)/4,#Caster=who,
                        #duration=800,#bMS=TRUE);
            Send(oRoom,@NewHold,#what=oElement,
                 #new_row=iRowSuccess,#new_col=iColSuccess,
                 #fine_row=iFineRowSuccess,#fine_col=iFineColSuccess);
                 
            iColSuccess = iNewCol;
            iRowSuccess = iNewRow;
            iFineColSuccess = iNewFineCol;
            iFineRowSuccess = iNewFineRow;
            iSteps = iSteps + 1;
         }
         else
         {
            break;
         }
         
         iCurDist = iCurDist + FINENESS;
      }

      if iSteps > 0
      {
         Send(SYS,@UtilGoNearSquare,#what=who,#where=oRoom,
                     #new_row=iRowSuccess,#new_col=iColSuccess,
                     #fine_row=iFineRowSuccess,#fine_col=iFineColSuccess,
                     #new_angle=iTargetAngle);
         Send(who,@MsgSendUser,#message_rsc=lightning_strike_dashed,
                               #parm1=iSteps);
         Send(self,@AddCooldown,#who=who);
         Post(who,@ClearAttackTimer);
         Post(who,@UserAttack,#what=oTarget);
      }
      else
      {
         Send(who,@MsgSendUser,#message_rsc=lightning_strike_no_space);
      }

      propagate;
   }

   SuccessChance(who=$)
   {
      return TRUE;
   }
   
   GetCooldown(who=$)
   {
      local i;
      
      for i in plCooldowns
      {
         if Nth(i,1) = who
         {
            return Nth(i,2);
         }
      }
      
      return 0;
   }

   AddCooldown(who=$)
   {
      local i;

      if who = $
      {
         return;
      }

      for i in plCooldowns
      {
         if Nth(i,1) = who
         {
            SetNth(i,2,Nth(i,2)+1);
            if Nth(i,2) >= piMaxUses
            {
               Send(who,@MsgSendUser,#message_rsc=lightning_strike_no_longer,
                                     #parm1=GetTimeRemaining(Nth(i,3))/1000);
            }
            return;
         }
      }
      
      plCooldowns = Cons([who,1,
                          CreateTimer(self,@ClearCooldown,piCooldownTime)],
                          plCooldowns);

      return;
   }

   ClearCooldown(timer=$)
   {
      local i;
      
      for i in plCooldowns
      {
         if Nth(i,3) = timer
         {
            if Nth(i,2) = piMaxUses
            {
               Send(Nth(i,1),@MsgSendUser,#message_rsc=lightning_strike_can_do_now);
            }

            SetNth(i,2,Nth(i,2)-1);
            
            if Nth(i,2) <= 0
            {
               SetNth(i,1,$);
               SetNth(i,2,0);
               SetNth(i,3,$);
               plCooldowns = DelListElem(plCooldowns,i);
            }
            else
            {
               SetNth(i,3,CreateTimer(self,@ClearCooldown,piCooldownTime));
            }
         }
      }
      
      return;
   }
   
   Delete()
   {
      local i;
      
      for i in plCooldowns
      {
         if Nth(i,3) <> $
         {
            DeleteTimer(Nth(i,3));
            SetNth(i,3,$);
            SetNth(i,2,0);
            SetNth(i,1,$);
            plCooldowns = DelListElem(plCooldowns,i);
         }
      }
      plCooldowns = $;
      
      propagate;
   }

   LineOfSight(oRoomData=$,
               row_start=0,col_start=0,fine_row_start=0,fine_col_start=0,
               row_end=0,col_end=0,fine_row_end=0,fine_col_end=0)
   "Returns TRUE if there is a line of sight between start and end"
   {
     local r;
     
     % First check if start can walk on a direct path to end.
     % If we can't move there, we assume vision through this
     % location is blocked as well.  This assumption is violated
     % by, for example, fences and altitude changes in the floor.

     r = Send(self,@LineOfSightInternal,#oRoomData=oRoomData,
                                        #row_start=row_start,
                                        #col_start=col_start,
                                        #fine_row_start=fine_row_start,
                                        #fine_col_start=fine_col_start,
                                        #row_end=row_end,
                                        #col_end=col_end,
                                        #fine_row_end=fine_row_end,
                                        #fine_col_end=fine_col_end);

     % we also possibly check the other way around,
     % because if end somehow DOES have LoS with start,
     % start also must have LoS with end.
     % This makes sure LoS is handled equally (fair) for both.
     if r = FALSE
     {
        r = Send(self,@LineOfSightInternal,#oRoomData=oRoomData,
                                           #row_start=row_end,
                                           #col_start=col_end,
                                           #fine_row_start=fine_row_end,
                                           #fine_col_start=fine_col_end,
                                           #row_end=row_start,
                                           #col_end=col_start,
                                           #fine_row_end=fine_row_start,
                                           #fine_col_end=fine_col_start);
     }

     return r;
   }
   
   LineOfSightInternal(oRoomData=$,
                       row_start=0,col_start=0,fine_row_start=0,fine_col_start=0,
                       row_end=0,col_end=0,fine_row_end=0,fine_col_end=0)
   {
      local r, c, r2, c2, dr, dc, iRow, iCol, iAtan, iSkip;

      % try get obj1 big coordinates (source)
      r = row_start;
      c = col_start;
 
      % no coordinates (big row/col can be $)
      if r = $ OR c = $
      {
         Debug("$ coordinates in flame dash");

         return FALSE;
      }
      else
      {
         % get fine values and scale to highres
         r = ((r * FINENESS) + fine_row_start) / 16;
         c = ((c * FINENESS) + fine_col_start) / 16;
      }

      % try get obj2 coordinates (destination)
      iRow = row_end;
      iCol = col_end;

      % no coordinates (big row/col can be $)
      if iRow = $ OR iCol = $
      {
         Debug("$ coordinates in flame dash end");

         return FALSE;
      }
      else
      {
         % get fine values and scale to highres
         iRow = ((iRow * FINENESS) + fine_row_end) / 16;
         iCol = ((iCol * FINENESS) + fine_col_end) / 16;    
      }

      % get deltas in highres
      dr = iRow - r;
      dc = iCol - c;

      % prepare first loop
      r2 = r;
      c2 = c;

      % get config setting for amount of steps to skip at the end
      % of LoS line, this modifies safespots
      iSkip = Send(Send(SYS, @GetSettings), @GetLOSSkip);

      % step from the source to the target on the highres grid.
      % depending on the skip amount, we either must reach
      % the destination completely (rare safespots)
      % or an adjacent/close square is enough (no safespots)
      while abs(dr) > iSkip OR abs(dc) > iSkip
      {
         % Figure out which direction we need to move
         % our 2D ray next (=step N,NE,E,SE,S,...)
         % We pick the best approximation of the 8 possible 

         % Only north or south are special cases.
         if dc = 0
         {
            if dr < 0 %N
            {
               r2 = r2 - 1;
            }
            else %S
            {
               r2 = r2 + 1;
            }
         }
         else
         {
            iAtan = 1000 * dr / dc;
         }

         % right half-plane
         if dc > 0 
         {
            if iAtan >= 2414 %S
            {
               r2 = r2 + 1;
            }
            else
            {
               if iAtan >= 414 %SE
               {
                  r2 = r2 + 1;
                  c2 = c2 + 1;
               }
               else
               {
                  if iAtan >= -414 %E
                  {
                     c2 = c2 + 1;
                  }
                  else
                  {
                     if iAtan >= -2414 %NE
                     {
                        r2 = r2 - 1;
                        c2 = c2 + 1;
                     }
                     else %N
                     {
                        r2 = r2 - 1;
                     }
                  }
               }
            }
         }

         % left half-plane
         if dc < 0 
         {
            if iAtan >= 2414 %N
            {
               r2 = r2 - 1;
            }
            else
            {
               if iAtan >= 414 %NW
               {
			      r2 = r2 - 1;
                  c2 = c2 - 1;                  
               }
               else
               {
                  if iAtan >= -414 %W
                  {
                     c2 = c2 - 1;
                  }
                  else
                  {
                     if iAtan >= -2414 %SW
                     {
			            r2 = r2 + 1;
                        c2 = c2 - 1;                        
                     }
                     else %S
                     {
                        r2 = r2 + 1;
                     }
                  }
               }
            }
         }

         % DEBUG - Puts item on LOS line
         % Send(SYS,@PutInRoom,#what=Create(&PlateArmor),#rid=piRoom_num,
         %    #row=(r/4),#col=(c/4),#fine_row=((r MOD 4)*16),#fine_col=((c MOD 4)*16));
		 
         % these calculations turn the highres values back into row/finerow
         % remember: 4 highres rows give a row, and a highres row has 16 finerows 
         if NOT CanMoveInRoomHighRes(oRoomData,
                    (r / 4), (c / 4), ((r MOD 4) * 16), ((c MOD 4) * 16),
                    (r2 / 4) , (c2 / 4), ((r2 MOD 4) * 16), ((c2 MOD 4) * 16))
         {
           return FALSE;
         }

		 % set new position as old
         r = r2;
         c = c2;

         % get deltas in highres
         dr = iRow - r;
         dc = iCol - c;
      }

      return TRUE;
   }

end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Meridian 59, Copyright 1994-2012 Andrew Kirmse and Chris Kirmse.
% All rights reserved.
%
% This software is distributed under a license that is described in
% the LICENSE file that accompanies it.
%
% Meridian is a registered trademark.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
TouchAttackSpell is PersonalEnchantment

% A touch attack spell is essentially a 'combat stroke' enchantment.

constants:

   include blakston.khd

   HITVALUE_MAX = 100
   POISON_DURATION = 30000 %%% in milliseconds
   POISON_LOSSRATE = 10000 %%% in health points * 10^-4 / second

resources:

   TouchAttackSpell_name_rsc = "Touch Spell"
   TouchAttackSpell_icon_rsc = light.bgf
   TouchAttackSpell_desc_rsc = "This is a touch spell that does damage."

   TouchAttack_Succeed_rsc = \
      "You have cast a touch attack on another player.  This is a bug.  "
      "Please report it.  Have a nice day."
   TouchAttack_missed1_sound = swswish1.wav
   TouchAttack_missed2_sound = swswish2.wav
   TouchAttack_missed3_sound = swswish3.wav
   
   TouchAttack_hit_sound = patk.wav
   
   ta_purge_worked_user = "Your violent blast of electricity disrupts the magic surrounding %s%s!"
   ta_purge_worked_target = "%s%s blasts you with electricity, disrupting the magic surrounding you!"
   ta_poison_worked_user = "Your acidic touch eats into %s%s's flesh, polluting %s blood!"
   ta_poison_worked_target = "%s%s's acidic touch eats into your flesh and pollutes your blood!"
   ta_blind_worked = "%s%s stumbles away, screaming and clutching %s eyes!"
   ta_hold_worked = "%s%s is frozen solid, unable to move even a finger."
   ta_heal_worked = "Shal'ille aids you in battle, healing you for ~g~B%i~B~n damage."

classvars:

   vrName = TouchAttackSpell_name_rsc
   vrIcon = TouchAttackSpell_icon_rsc
   vrDesc = TouchAttackSpell_desc_rsc

   vrMiss_sound = $
   
   vrMissed_message_attacker = $
   vrMissed_message_defender = $

   vrAlreadyEnchanted = PersonalEnchantment_already_enchanted_rsc
   vrEnchantment_On = PersonalEnchantment_On_rsc
   vrEnchantment_Off = PersonalEnchantment_Off_rsc
   vrSuccess = PersonalEnchantment_Success_rsc
   vrSucceed = TouchAttack_Succeed_rsc

   vrPlayer_hit_something = $
   vrPlayer_was_hit = $
   vrPlayer_killed_something = $
   vrPlayer_was_killed = $

   viIndefinite = ARTICLE_NONE
   viDefinite = ARTICLE_NONE

   viSchool = 0
   viSpell_num = 0
   viStroke = 0

   viSpellExertion = 2

	% Chance to increase is one in viChance_To_Increase.
   viChance_To_Increase = 60

   % Touch spells typically do good damage but are unaffected by typical weapon
   %  bonuses.
   viBase_Damage = 6

   % Touch spell range can vary, but is typically good.     
   viRange = 2

   % Touch spells are now linked to punch attacks, so make it do punch damage
   %  for default.
   viAttackType = ATCK_WEAP_UNARMED+ATCK_WEAP_PUNCH
   % Touch spells typically DO have a spell type.
   viSpellType = 0          

   viPostCast_time = 1

   % Cannot enchant others with touch attacks.
   vbCanCastOnOthers = FALSE

properties:

   plPrerequisites = $
   plReagents = $
   
   % The following are chances to proc special effects on a successful touch attack.
	% To get the proc chance, the procfactor (0 to 15) is multiplied by this value
	% and divided by 1000. Thus, a value of 10 results in a procchance of 15 percent,
	% while a value of 20 will result in a 30 percent chance to proc.
   piBlind_chance = 10
   piHold_chance = 10
   piPurge_chance = 10
   piPoison_chance = 10
   piHeal_chance = 10
   
messages:

   ImproveStroke(who=$,target=$)
   {
      Send(self,@ImproveAbility,#who=who,#target=target);
      
      return;
   }

   CanPayCosts(who = $, lTargets = $, iSpellPower = 0)
   {
      propagate;
   }

   CastSpell(who = $,iSpellPower=0,lTargets=$)
   {
      % Remove other touch attack spells.  Won't remove self, because
      %  we've checked for re-enchantment in CanPayCosts.
      Send(who,@RemoveEnchantmentClass,#class=&TouchAttackSpell);
      
      propagate;
   }

   GetNumSpellTargets()
   {
      return 0;
   }

   CheckWeaponAndDoAnimation(who=$,weapon_used=$,victim=$)
   "Spell does not require a weapon, but a player may use this spell even"
   "if they are armed."
   "Also does the cast animation.  In future, may provide different grfx"
   "for different touch spells."
   {
      Send(who,@DoCast);
      
      return TRUE;
   }

   ToHitImprovers(raw_hitroll=0)
   "A weapon stroke may have IMPROVERS, which may boost the performance of "
   "the stroke.  Example, if a player has renweed, that may boost his thrust "
   "Default, return the hitroll raw."
   {
      return Raw_hitroll; 
   }

   DamageFactors(damage=0,who=$,victim=$,procfactor=0)
    "Here, we handle procs as well as damage adjustments."
   {
      local oSpell, iKarma, iHeal;
	    
      procfactor = procfactor * bound(send(who,@GetBaseMaxHealth)-50,0,50)/50;
      
      if viSpell_num = SID_ZAP
      {
         oSpell = send(SYS,@FindSpellByNum,#num=SID_PURGE);
         
         if random(1,1000) <= piPurge_chance*procfactor
         {
            %% Gotta have something to try to remove....
            if Send(victim,@IsEnchanted)
            {
               % Try to purge off random(25,75)% of the enchantments.
               if send(oSpell,@DoPurge,#who=victim,#iChance=random(25,75))
               {
                  % Only tell our victim if they lost enchantments.
                  send(victim,@MsgSendUser,#message_rsc=ta_purge_worked_target,
                       #parm1=send(who,@GetCapDef),#parm2=send(who,@GetName));
               }

               % Tell the zapper.
               send(who,@MsgSendUser,#message_rsc=ta_purge_worked_user,
                    #parm1=send(victim,@GetDef),#parm2=send(victim,@GetName));
            }
         }
      }
      
      if viSpell_num = SID_TOUCH_OF_FLAME
      {
         oSpell = send(SYS,@FindSpellByNum,#num=SID_BLIND);
         
         if random(1,1000) <= piBlind_chance*procfactor
         {
            %% no duplicates
            if not Send(victim,@IsEnchanted,#what=oSpell)
            {        
               send(oSpell,@CastSpell,#who=self,#ltargets=[victim],#iSpellPower=50);
               send(who,@MsgSendUser,#message_rsc=ta_blind_worked,
                     #parm1=send(victim,@GetCapDef),#parm2=send(victim,@GetName),
                     #parm3=send(victim,@GetHisher));
            }
         }
      }
      
      if viSpell_num = SID_ICY_FINGERS
      {
         oSpell = send(SYS,@FindSpellByNum,#num=SID_HOLD);

         if random(1,1000) <= piHold_chance*procfactor
         {
            %% no duplicates
            if not Send(victim,@IsEnchanted,#what=oSpell)
            {        
               send(oSpell,@CastSpell,#who=self,#ltargets=[victim],#ispellpower=99);
               send(who,@MsgSendUser,#message_rsc=ta_hold_worked,
                  #parm1=send(victim,@GetCapDef),#parm2=send(victim,@GetName));
            }
         }
      }

      if viSpell_num = SID_ACID_TOUCH
      {
         oSpell = Send(SYS,@FindSpellByNum,#num=SID_POISON);
         
         if random(1,1000) <= piPoison_chance*procfactor
         {

            send(oSpell,@MakePoisoned,#who=victim,
                #lossrate=POISON_LOSSRATE,#duration=POISON_DURATION);
            send(who,@MsgSendUser,#message_rsc=ta_poison_worked_user,
                 #parm1=send(victim,@GetDef),#parm2=send(victim,@GetName),
                 #parm3=send(victim,@GetHisher));
            send(victim,@MsgSendUser,#message_rsc=ta_poison_worked_target,
                 #parm1=send(victim,@GetCapDef),#parm2=send(victim,@GetName));
         }
      }

      if viSpell_num = SID_HOLY_TOUCH
      {

         % Avoid the condition of checking damage on a nil victim (like when
         %  just querying average damage).
         if victim <> $
         {
            
            iKarma = Send(victim,@GetKarma,#detect=TRUE);

            if iKarma > 0
            {
               damage = 0;
            }
            else
            {
               damage = damage * bound(-(iKarma*2),0,100)/100;
            }
                   
            if Send(victim,@IsUndead)
            {
               damage = damage+500;
            }
         }

         if random(1,1000) <= piHeal_chance*procfactor
         {
		    iHeal = random(damage/200,damage/100);
            send(who,@GainHealth,#amount=iHeal);
            send(who,@MsgSendUser,#message_rsc=ta_heal_worked,#parm1=iHeal);
         }
      }

      return damage;
   }

   GetHitsound()
   {
      return touchattack_hit_sound;
   }

   %%% This section for combat

   %%% These are the weapon functions

   % What's the stroke number?
   % This here is a pure backup. Different touch attacks use different
   % factors to determine their secondary chance to hit. Check the
   % individual spells for details.
   GetProf(who=$)
   {
      local iProf;

      Send(who,@FlipSkillAtrophyFlag,#SKID=SKID_PUNCH);
      
      iProf = Send(who,@GetMysticism);
      
      return iProf;
   }

   GetStroke(who=$)
   {
      % Touch attacks are "backwards", they use the specialized spell as the
      %  stroke, or primary bonus to hit.
      Send(who,@FlipSpellAtrophyFlag,#SID=viSpell_num);

      return Send(who,@GetSpellAbility,#spell_num=viSpell_num);
   }

   GetAttackType(weapon_used=$)
   {
      return viAttackType;
   }

   GetAttackSpell(weapon_used=$)
   {
      return viSpellType;
   }

   GetParryAbility()
   {
      % Touch attacks have no parrying ability.
      return 0;
   }

   %%% These are the stroke functions

   % Can this touch attack be blocked?
   CanBlock()
   {
      return TRUE;
   }

   % Can this touch attack be parried?
   CanParry()
   {
      return TRUE;
   }

   % Can this touch attack be blocked?
   CanDodge()
   {
      return TRUE;
   }

   % This returns the "weapon" name for combat attacks.
   GetAttackName()
   {
      return vrName;
   }

   GetRange(weapon_used = $)
   "This returns the range of the spell.  Usually, this hovers around 2-3."
   {
      return viRange;
   }

   CheckSpecial(who=$,victim=$)
   "Checks to see if there are any special circumstances which prevents"
   "the target player from performing this spell."
   {
      return TRUE;
   }


   FindDamage(weapon_used=$,who=$,victim=$)
   "Damage for attack spells is determined largely by expertise in the spell."
   {
      local i, damage, iAbility, iProcfactor;

      % base weapon damage
      damage = viBase_damage;
 
      iProcfactor = 5;

      for i in send(who,@GetPlayerUsing)
      {
         if IsClass(i,&JewelOfFroz)
         {
            % Each jewel of Froz adds up to 3 to base damage depending on HPs.
            damage = damage + bound(send(who,@GetBaseMaxHealth)-40,0,60)/20;
            % Each equipped JoFincreases the chance to proc effects.
            iProcfactor = iProcfactor + 5;
         }
      }

	  damage = damage*100;
	  
      % scale the basedamage with the caster's ability in the spell
      iAbility = Send(who,@GetSpellAbility,#spell_num=viSpell_num);
      damage = damage * (50 + ((iAbility + 1) / 2)) / 100;

      % scale proficiency bonus with HPs instead of spell ability
      damage = damage + bound(send(who,@GetBaseMaxHealth),0,100)*damage/100;

      % touchspells are boosted by mysticism instead of might
      damage = damage*(50 + send(who,@GetMysticism))/100;
       
      % allow for damage adjustments and procs
      damage = Send(self,@DamageFactors,#damage=damage,#who=who,
                          #victim=victim,#procfactor=iProcfactor);
      return damage;
   }


   PlayerWasHitMsg(who=$,attacker=$,damage=$)
   "The stroke may choose it's own damage give or recieve message.  Otherwise "
   "player.kod will just choose a default - which is true for most weapon-"
   "based combat strokes (but not true for most punch strokes or touch spells."
   {
      if vrPlayer_was_hit = $
      {
         return FALSE;
      }

      Send(who,@MsgSendUser,#message_rsc=vrPlayer_was_hit,
           #parm1=Send(attacker,@GetCapDef),#parm2=Send(attacker,@GetName));
           
      return TRUE;
   }

   PlayerHitSomethingMsg(who=$,victim=$,damage=$,color_rsc=$)
   "The stroke may choose it's own damage give or recieve message.  Otherwise "
   "player.kod will just choose a default - which is true for most weapon-"
   "based combat strokes (but not true for most punch strokes or touch spells."
   {
      if vrPlayer_hit_something = $
      {
         return FALSE;
      }
       
      Send(who,@MsgSendUser,#message_rsc=vrPlayer_hit_something,
           #parm1=color_rsc,#parm2=Send(victim,@GetDef),
           #parm3=Send(victim,@GetName));
          
      return TRUE;
   }

   SendMissMessageToAttacker(who=$,victim=$,color_rsc=$)
   {
      local iRandom, rSound;
      
      % 'miss' sound
      if vrMiss_Sound = $
      {
         % Play a random miss sound.
         iRandom = random(1,3);
         if iRandom = 1
         {
            rSound = TouchAttack_missed1_sound;
         }
         else
         {
            if iRandom = 2
            {
               rSound = TouchAttack_missed2_sound;
            }
            else
            {
               rSound = TouchAttack_missed3_sound;
            }
         }
      }
      else
      {
         rSound = vrMiss_Sound;
      }
      
      Send(Send(who,@GetOwner),@SomethingWaveRoom,#what=who,#wave_rsc=rSound);
      
      % Text messages
      if vrMissed_Message_Attacker <> $
      {
         Send(who,@MsgSendUser,#message_rsc=vrMissed_Message_Attacker,
              #parm1=color_rsc,#parm2=vrName,#parm3=Send(victim,@GetDef),
              #parm4=Send(victim,@GetName));
              
         return TRUE;
      }
      
      return;
   }

   SendMissMessageToDefender(who=$,attacker=$)
   {
      if vrMissed_message_Defender <> $
      {
         Send(who,@MsgSendUser,#message_rsc=vrMissed_Message_Defender,
              #parm1=Send(attacker,@GetCapDef),#parm2=Send(attacker,@GetName),
              #parm3=vrName);
              
         return TRUE;
      }

      return;
   }

   PlayerKilledSomethingMsg(who=$,victim=$,damage=$)
   "The stroke may choose it's own damage give or recieve message.  Otherwise"
   "player.kod will offer the default 'You killed the whatever' message."
   {
       if vrPlayer_killed_Something = $
       {
         return FALSE ;
       }
       
       Send(who,@MsgSendUser,#message_rsc=vrPlayer_killed_something,
            #parm1=Send(victim,@GetCapDef),#parm2=Send(victim,@GetName));
                
       return TRUE;
   }

   PlayerWasKilledMsg(who=$,attacker=$,damage=$)
   "The stroke may choose it's own damage give or recieve message.  Otherwise"
   "player.kod will just choose a default - as it does for most strokes."
   {
       if vrPlayer_was_killed = $
       {
         return FALSE ;
       }
       
       Send(who,@MsgSendUser,#message_rsc=vrPlayer_was_killed,
            #parm1=Send(attacker,@GetDef),#parm2=Send(attacker,@GetName));
            
       return TRUE;
   }

   %%% Enchantment support

   GetDuration(iSpellpower=$)
   {
      local iDuration;

      iDuration = 60;
      % 60 minutes flat
      iDuration = iDuration * 60 * 1000;  

      return iDuration;
   }  

   GetStateValue(iSpellpower=$)
   {
      Return iSpellpower;
   }


end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

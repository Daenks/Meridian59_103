% Meridian 59, Copyright 1994-2012 Andrew Kirmse and Chris Kirmse.
% All rights reserved.
%
% This software is distributed under a license that is described in
% the LICENSE file that accompanies it.
%
% Meridian is a registered trademark.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Item is Object

constants:

   include blakston.khd
   include protocol.khd
   
resources:

   item_this = "This "
   item_blank_template = "%q"
   item_desc_template = "%s%s"
   resource_blank = ""
   
   item_try_use_cursed_rsc = \
      "As you pick the item up, you feel a will greater than your own "
      "overwhelm your mind!  Not of your own volition, you try to put it on!"

   item_broken_battle = "Your %s shatters in the heat of battle!"
   item_broken_battle_plural = "Your %s shatter in the heat of battle!"
   item_broken_battle_clothing = "Your %s falls into useless tatters!"
   item_broken_battle_clothing_plural = "Your %s fall into useless tatters!"

   itematt_generic = \
      " At first glance, it seems quite ordinary, but there is something odd "
      "about it you can't put your finger on."

   nakedleftarm_male = blg.bgf
   nakedrightarm_male = brg.bgf
   nakedleftarm_female = blh.bgf
   nakedrightarm_female = brh.bgf

   item_condition_exc = " is in immaculate condition."
   item_condition_exc_mended = \
      " is in excellent condition, but has been patched before."
   item_condition_good = " is scuffed and slightly worn."
   item_condition_med = " has a few unsightly rips."
   item_condition_poor = " is in tatters, and barely holding together."
   item_condition_broken = " is covered in filth and ripped beyond use."
   
   special_properties_header = "\n\nThis item has the following properties:\n"

classvars:
   
   vrItem_broken = item_broken_battle

   vrPoss_article = item_this
   viUse_type = ITEM_CANT_USE
   viItem_type = ITEMTYPE_MISC

   viUse_amount = 1

   viHits_init_min = 1
   viHits_init_max = 1

   viBulk = 10
   viWeight = 10

   viValue_average = 10

   viGround_group = 1
   viInventory_group = 1
   viBroken_group = $    % if set to nil, no group exists

   % How much this item will help or hinder spell usage.
   viSpell_modifier = 0

   vrIcon_male       = $
   vrIcon_female     = $
   vrLeftArm_male    = $
   vrLeftArm_female  = $
   vrRightArm_male   = $
   vrRightArm_female = $
   vrLegs_male       = $
   vrLegs_female     = $

   vbShow_condition =  FALSE
   vrCondition_exc =   item_condition_exc
   vrCondition_exc_mended = item_condition_exc_mended
   vrCondition_good =  item_condition_good
   vrCondition_med =   item_condition_med
   vrCondition_poor =  item_condition_poor
   vrCondition_broken = item_condition_broken
   
   % Items may have a different appearance once revealed. Values are zero if not applicable.
   viUnrevealedColor = 0
   viRevealedColor = 0

properties:

   viObject_flags = OF_GETTABLE
   piHits_init = 0
   piHits = 0
      
   plItem_attributes = $

   piItem_flags = 0

   % List of enchantments applied by radius spells.
   % Each element is [song object, spellpower, caster]
   % Support for players, monsters, and items
   plRadiusEnchantments = $

messages:

   Constructor(corpse=$)
   {
      local iHits_average, oItemAtt;

      piHits_init = Random(viHits_init_min,viHits_init_max);
      piHits = piHits_init;
      if corpse <> $
      {
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=IA_CORPSEPOINTER);
         if Send(oItemAtt,@ReqAddToItem,#oItem=self)
         {
            Send(oItemAtt,@AddToItem,#oItem=self,#state1=corpse);
         }            
      }
      
      if viUnrevealedColor <> 0
         AND Send(self,@GetPaletteTranslation) = 0
      {
         Send(self,@SetPaletteTranslation,#translation=viUnrevealedColor);
      }
      
      propagate;
   }

   SetItemPlayerFlag(who=$)
   {
      return;
   }

   AppendDesc()
   {
      % This is special 'status' stuff, like the number of 
      %  number items you have left, or the condition of your 
      %  weapon.
      local rItem_condition, iHit_percent, i, oSpell, oSkill,
         iHigh_level, iFarenPower, iRiijaPower, iKraananPower, iJalaPower,
         iShalPower, iQorPower, iPower, iInstrumentPower;

      for i in plObject_attributes
      {
         Send(i,@AttributeDesc);
      }

      if IsClass(self,&Weapon)
      {
         AppendTempString(special_properties_header);
         if Send(self,@GetDamage) <> 0
         {
            Send(SYS,@IntToString,#num=Send(self,@GetDamage),
               #decimals=2,#append=TRUE);
            AppendTempString(" base wepon damage\n");
         }
         if Send(self,@GetProficiencyBonus) <> 0
         {
            Send(SYS,@IntToString,#num=Send(self,@GetProficiencyBonus),
               #decimals=2,#append=TRUE);
            AppendTempString(" added damage from proficiency\n");
         }

         if Send(self,@GetStrokeMod,#Skill_num=SKID_STAB) <> 0
         {
            AppendTempString(Send(self,@GetStrokeMod,#Skill_num=SKID_STAB));
            AppendTempString(" \% damage when stabbing\n");
         }
         if Send(self,@GetStrokeMod,#Skill_num=SKID_STRIKE) <> 0
         {
            AppendTempString(Send(self,@GetStrokeMod,#Skill_num=SKID_STRIKE));
            AppendTempString(" \% damage when striking\n");
         }
         if Send(self,@GetStrokeMod,#Skill_num=SKID_SLASH) <> 0
         {
            AppendTempString(Send(self,@GetStrokeMod,#Skill_num=SKID_SLASH));
            AppendTempString(" \% damage when slashing\n");
         }
         if Send(self,@GetStrokeMod,#Skill_num=SKID_THRUST) <> 0
         {
            AppendTempString(Send(self,@GetStrokeMod,#Skill_num=SKID_THRUST));
            AppendTempString(" \% damage when thrusting\n");
         }
         if Send(self,@GetStrokeMod,#Skill_num=SKID_FIRE) <> 0
         {
            AppendTempString(Send(self,@GetStrokeMod,#Skill_num=SKID_FIRE));
            AppendTempString(" \% damage\n");
         }
         if Send(self,@GetStrokeMod,#Skill_num=SKID_TOUCH) <> 0
         {
            AppendTempString(Send(self,@GetStrokeMod,#Skill_num=SKID_TOUCH));
            AppendTempString(" \% damage\n");
         }
         if Send(self,@GetPrimaryScaling) <> 0
         {
            AppendTempString(Send(self,@GetPrimaryScaling));
            AppendTempString(" \% scaling with the weapon's primary stat\n");
         }
         if Send(self,@GetSecondaryScaling) <> 0
         {
            AppendTempString(Send(self,@GetSecondaryScaling));
            AppendTempString(" \% scaling with the weapon's secondary stat\n");
         }
         if Send(self,@GetHitMod) <> 0
         {
            AppendTempString(Send(self,@GetHitMod));
            AppendTempString(" offense rating\n");
         }

         if Send(self,@GetDisarmMod) <> 0
         {
            if Send(self,@GetDisarmMod) <> $
            {
               AppendTempString(Send(self,@GetDisarmMod));
               AppendTempString(" \% increased disarm ability\n");
            }
            else
            {
               AppendTempString("is not suited for disarming\n");
            }
         }
         if Send(self,@GetParryMod) <> 0
         {
            if Send(self,@GetDisarmMod) <> $
            {
               AppendTempString(Send(self,@GetParryMod));
               AppendTempString(" \% increased parry ability\n");
            }
            else
            {
               AppendTempString("is not suited for parrying\n");
            }
         }
         if Send(self,@GetDeviation) <> 0
         {
            AppendTempString(Send(self,@GetDeviation));
            AppendTempString(" \% damage spread\n");
         }

         if Send(self,@GetRange) <> 0
         {
            Send(SYS,@IntToString,#num=Send(self,@GetRange)*100/64,
               #decimals=2,#append=TRUE);
            AppendTempString(" range\n\n");
         }

         if Send(self,@GetPrimaryStat) <> 0
         {
            AppendTempString("The primary stat for this weapon is ");
            if Send(self,@GetPrimaryStat) = 1
            {
               AppendTempString("might.\n");
            }
            if Send(self,@GetPrimaryStat) = 2
            {
               AppendTempString("intellect.\n");
            }
            if Send(self,@GetPrimaryStat) = 3
            {
               AppendTempString("stamina.\n");
            }
            if Send(self,@GetPrimaryStat) = 4
            {
               AppendTempString("agility.\n");
            }
            if Send(self,@GetPrimaryStat) = 5
            {
               AppendTempString("mysticism.\n");
            }
            if Send(self,@GetPrimaryStat) = 6
            {
               AppendTempString("aim.\n");
            }
         }

         if Send(self,@GetSecondaryStat) <> 0
         {
            AppendTempString("The secondary stat for this weapon is ");
            if Send(self,@GetSecondaryStat) = 1
            {
               AppendTempString("might.\n\n");
            }
            if Send(self,@GetSecondaryStat) = 2
            {
               AppendTempString("intellect.\n\n");
            }
            if Send(self,@GetSecondaryStat) = 3
            {
               AppendTempString("stamina.\n\n");
            }
            if Send(self,@GetSecondaryStat) = 4
            {
               AppendTempString("agility.\n\n");
            }
            if Send(self,@GetSecondaryStat) = 5
            {
               AppendTempString("mysticism.\n\n");
            }
            if Send(self,@GetSecondaryStat) = 6
            {
               AppendTempString("aim.\n\n");
            }
         }

         if Send(self,@GetAttackType) <> 0
         {
            for i in Send(SYS,@GetAttackTypeList)
            {
               if (Send(self,@GetAttackType) & i)
               {
                  AppendTempString("This weapon deals ");
                  AppendTempString(Send(SYS,@GetAttackDamageTypeName,#type=i));
                  AppendTempString(" damage.\n");
               }
            }
         }

         if Send(self,@GetSpellType) <> 0
         {
            for i in Send(SYS,@GetSpellTypeList)
            {
               if (Send(self,@GetSpellType) & i)
               {
                  AppendTempString("This weapon deals ");
                  AppendTempString(Send(SYS,@GetSpellDamageTypeName,#type=i));
                  AppendTempString(" damage.\n");
               }
            }
         }

         if Send(self,@GetSpellType) <> 0 OR Send(self,@GetAttackType) <> 0
         {
            AppendTempString("\n");
         }

         if Send(self,@GetAttributes) <> $
         {
            for i in Send(self,@GetAttributes)
            {
               if Send(self,@GetNumFromCompound,#compound=First(i)) = WA_PARALYZER
                  AND Send(self,@GetIDStatusFromCompound,#compound=First(i)) 
               {
                  AppendTempString("This weapon has a ");
                  AppendTempString("15\% chance to cast Hold on hit.\n");
               }
               if Send(self,@GetNumFromCompound,#compound=First(i)) = WA_BLINDER  
                  AND Send(self,@GetIDStatusFromCompound,#compound=First(i))
               {
                  AppendTempString("This weapon has a ");
                  AppendTempString("15\% chance to cast Blind on hit.\n");
               }
               if Send(self,@GetNumFromCompound,#compound=First(i)) = WA_BONKER
                  AND Send(self,@GetIDStatusFromCompound,#compound=First(i))
               {
                  AppendTempString("This weapon has a ");
                  AppendTempString("8\% chance to cast Bonk on hit.\n");
               }
               if Send(self,@GetNumFromCompound,#compound=First(i)) = WA_PURGER
                  AND Send(self,@GetIDStatusFromCompound,#compound=First(i))
               {
                  AppendTempString("This weapon has a ");
                  AppendTempString("15\% chance to cast Purge on hit.\n");
               }
               if Send(self,@GetNumFromCompound,#compound=First(i)) = WA_TWISTER
                  AND Send(self,@GetIDStatusFromCompound,#compound=First(i))
               {
                  AppendTempString("This weapon has a ");
                  AppendTempString("8\% chance to disorient victim on hit.\n");
               }
               if Send(self,@GetNumFromCompound,#compound=First(i)) = WA_Vamper
                  AND Send(self,@GetIDStatusFromCompound,#compound=First(i))
               {
                  AppendTempString("This weapon has a ");
                  AppendTempString("10\% chance to gain up to 8 health on hit.\n");
               }
            }
            AppendTempString("\n");
         }
      }

      if IsClass(self,&Armor)
      {
         AppendTempString(special_properties_header);
         if Send(self,@GetPhysicalReductionFlat) <> 0
         {
            Send(SYS,@IntToString,#num=Send(self,@GetPhysicalReductionFlat),
               #decimals=2,#append=TRUE);
            AppendTempString(" points of physical damage reduction\n");
         }
         
         if Send(self,@GetMagicalReductionFlat) <> 0
         {
            Send(SYS,@IntToString,#num=Send(self,@GetMagicalReductionFlat),
               #decimals=2,#append=TRUE);
            AppendTempString(" points of magical damage reduction\n");
         }
         
         if Send(self,@GetPhysicalReductionFactor) <> 0
         {
            Send(SYS,@IntToString,#num=Send(self,@GetMagicalReductionFlat),
               #decimals=1,#append=TRUE);
            AppendTempString(" \% physical damage reduction\n");
         }
         
         if Send(self,@GetMagicalReductionFactor) <> 0
         {
            Send(SYS,@IntToString,#num=Send(self,@GetMagicalReductionFlat),
               #decimals=1,#append=TRUE);
            AppendTempString(" \% magical damage reduction\n");
         }
         
         if Send(self,@GetCombatModDefense) <> 0
         {
            AppendTempString(Send(self,@GetCombatModDefense));
            AppendTempString(" defense rating\n");
         }

         if Send(self,@GetCombatModOffense) <> 0
         {
            AppendTempString(Send(self,@GetCombatModOffense));
            AppendTempString(" offense rating\n");
         }

         if Send(self,@GetCombatModMelee) <> 0
         {
            Send(SYS,@IntToString,#num=Send(self,@GetCombatModMelee),
               #decimals=1,#append=TRUE);
            AppendTempString(" \% melee damage bonus\n");
         }

         if Send(self,@GetCombatModRanged) <> 0
         {
            Send(SYS,@IntToString,#num=Send(self,@GetCombatModRanged),
               #decimals=1,#append=TRUE);
            AppendTempString(" \% ranged damage bonus\n");
         }

         if Send(self,@GetCombatModMagic) <> 0
         {
            Send(SYS,@IntToString,#num=Send(self,@GetCombatModMagic),
               #decimals=1,#append=TRUE);
            AppendTempString(" \% touch attack damage bonus\n");
         }

         if Send(self,@GetSkillmods) <> $
         {
            for i in Send(self,@GetSkillmods)
            {
               oSkill = Send(SYS,@FindSkillByNum,#num=First(i));
               AppendTempString("increases your ability in the skill ");
               AppendTempString(Send(oSkill,@GetName));
               AppendTempString(" by ");
               AppendTempString(Nth(i,2));
               AppendTempString(" points\n");
            }
         }

         if Send(self,@GetSpellmods) <> $
         {
            for i in Send(self,@GetSpellmods)
            {
               oSpell = Send(SYS,@FindSpellByNum,#num=First(i));
               AppendTempString("increases your ability in the spell ");
               AppendTempString(Send(oSpell,@GetName));
               AppendTempString(" by ");
               AppendTempString(Nth(i,2));
               AppendTempString(" points\n");
            }
         }
         AppendTempString("\n");
      }

      if IsClass(self,&Armor) OR IsClass(self,&Weapon)
      {
         iPower = Send(self,@GetSpellpowerMod);
         oSpell = Send(SYS,@FindSpellByNum,#num=SID_LIGHT);
         iFarenPower = Send(self,@SpellPowerHookForItems,#oSpell=oSpell)+iPower;
         oSpell = Send(SYS,@FindSpellByNum,#num=SID_BLINK);
         iRiijaPower = Send(self,@SpellPowerHookForItems,#oSpell=oSpell)+iPower;
         oSpell = Send(SYS,@FindSpellByNum,#num=SID_BLESS);
         iKraananPower = Send(self,@SpellPowerHookForItems,#oSpell=oSpell)+iPower;
         oSpell = Send(SYS,@FindSpellByNum,#num=SID_MIRTH);
         iJalaPower = Send(self,@SpellPowerHookForItems,#oSpell=oSpell)+iPower;
         oSpell = Send(SYS,@FindSpellByNum,#num=SID_SEANCE);
         iShalPower = Send(self,@SpellPowerHookForItems,#oSpell=oSpell)+iPower;
         oSpell = Send(SYS,@FindSpellByNum,#num=SID_DARKNESS);
         iQorPower = Send(self,@SpellPowerHookForItems,#oSpell=oSpell)+iPower;

         iInstrumentPower = 0;
         If IsClass(self,&Instrument)
         {
            iInstrumentPower = Send(self,@GetInstrumentLevel);
         }

         if iFarenPower <> 0
            OR iRiijaPower <> 0
            OR iKraananPower <> 0
            OR iJalaPower <> 0
            OR iShalPower <> 0
            OR iQorPower <> 0
            OR iInstrumentPower <> 0
         {
            if iFarenPower = iRiijaPower
               AND iRiijaPower = iKraananPower
               AND iKraananPower = iJalaPower
               AND iJalaPower = iShalPower
               AND iShalPower = iQorPower
               AND iFarenPower <> 0
            {
               AppendTempString(iFarenPower);
               AppendTempString(" general spellpower\n");
            }
            else
            {
               if iFarenPower <> 0
               {
                  AppendTempString(iFarenPower);
                  AppendTempString(" Faren spellpower\n");
               }
               if iRiijaPower <> 0
               {
                  AppendTempString(iRiijaPower);
                  AppendTempString(" Riija spellpower\n");
               }
               if iKraananPower <> 0
               {
                  AppendTempString(iKraananPower);
                  AppendTempString(" Kraanan spellpower\n");
               }
               if iJalaPower <> 0
               {
                  AppendTempString(iJalaPower);
                  AppendTempString(" Jala spellpower\n");
               }
               if iShalPower <> 0
               {
                  AppendTempString(iShalPower);
                  AppendTempString(" Shal'ille spellpower\n");
               }
               if iQorPower <> 0
               {
                  AppendTempString(iQorPower);
                  AppendTempString(" Qor spellpower\n");
               }

               if iInstrumentPower <> 0
               {
                  AppendTempString(iInstrumentPower);
                  AppendTempString(" Jala instrument power\n");
               }
            }
            AppendTempString("\n");
         }
         
         if Send(self,@GetCurrentResistances) <> $
         {
            for i in Send(self,@GetCurrentResistances)
            {
               AppendTempString(Nth(i,2));
               AppendTempString("\% ");
               AppendTempString(Send(SYS,@GetResistanceName,#type=Nth(i,1)));
               AppendTempString("\n");
            }
            AppendTempString("\n");
         }

         if Send(self,@GetQuality) <> 0
         {
            AppendTempString("The overall quality level of this item is ");
            AppendTempString(Send(self,@GetQuality));
            AppendTempString(".\n\n");
         }

         if vbShow_Condition AND piHits_init > 0
         {
            rItem_condition = vrCondition_exc;
         
            iHit_Percent = (100 * piHits) / piHits_init;
         
            if iHit_Percent > 90
            {
               rItem_condition = vrCondition_exc;
            }
            else
            { 
               if iHit_Percent > 65
               {
                  ritem_condition = vrCondition_good;
               }
               else
               {
                  if iHit_Percent > 30
                  {
                     ritem_condition = vrCondition_med;
                  }
                  else
                  {
                     if piHits > 0
                     {
                        ritem_condition= vrCondition_poor;
                     }
                     else
                     {
                        ritem_condition= vrCondition_broken;
                     }
                  }
               }
            }

            AppendTempString(vrPoss_Article);
            AppendTempString(Send(self,@GetName));
            AppendTempString(rItem_condition);
            AppendTempString(" \(");
            AppendTempString(piHits);
            AppendTempString("/");
            AppendTempString(piHits_init);
            AppendTempString("\)");
         }
      }

      return;
   }

   GetAttributes()
   {
      return plItem_Attributes;
   }

   GetResistanceModifiers()
   {
      return $;
   }
   
   DoBaseDesc()
   {
      local lData;

      % This is the meat of the description for items.
      if Send(self,@HasAttribute,#ItemAtt=IA_NEW_DESCRIPTION)
      {
         lData = Send(self,@GetAttributeData,#ItemAtt=IA_NEW_DESCRIPTION);
         AppendTempString(Nth(lData,2));
      }
      else
      {
         AppendTempString(vrDesc);
      }
      
      return;
   }

   CreateDesc(bShowall=FALSE)
   {
      local bAlreadyBlind, bIdentified, oItemAtt, i, iNum;

      bAlreadyBlind = FALSE;
      ClearTempString();
      Send(self,@DoBaseDesc);

      if Send(self,@HasAttribute,#ItemAtt=IA_MISDIRECTION) AND NOT bShowAll
      {
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=IA_MISDIRECTION);
         Send(oItemAtt,@AppendMisdirectedDesc,#oItem=self,
              #lData=Send(self,@GetAttributeData,#ItemAtt=IA_MISDIRECTION));
      }
      else
      {
         for i in plItem_Attributes
         {
            iNum = Send(self,@GetNumFromCompound,#compound=First(i));
            oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
            bIdentified = Send(self,@GetIDStatusFromCompound,
                               #compound=First(i));

            if NOT (bIdentified OR bShowAll)
            {
               if bAlreadyBlind
               {
                  continue;
               }
               else
               {
                  AppendTempString(itematt_generic);
                  bAlreadyBlind = TRUE;
               }
            }
            else
            {
               Send(oItemAtt,@AppendDesc,#oItem=self,#lData=i);
            }
         }       
      }

      % Special things for number items, etc.
      Send(self,@AppendDesc);  
      
      return;
   }
   
   ShowDesc(bShowAll = FALSE)
   {
      Send(self,@CreateDesc,#bShowAll=bShowAll);      
      AddPacket(4,item_blank_template,4,GetTempString());

      return;
   }

   ReqRepair()
   {
      return FALSE;
   }

   DestroyDisposable()
   {
      if Send(self,@HasAttribute,#ItemAtt=IA_BONDED)
      {
         return;
      }
      
      Send(self,@Delete);
      
      return;
   }

   GetItemUseType()
   {
      if piHits <= 0
      {
         return ITEM_BROKEN;
      }
      
      return viUse_type;
   }

   GetItemUseAmount()
   {
      return viUse_amount;
   }

   GetInitValue()
   {
      return viValue_average;
   }

   GetValue()
   {
      local iPercent, iValue, iFinal, i, oItemAtt, iNum;

      % This factors in the item's quality squared since both current hits and
      % maximum hits are scaled by quality.
      iPercent = (100*piHits_init*piHits)/(viHits_init_max*viHits_init_max);
      iValue = Send(self,@GetInitValue);
      
      iFinal = (iValue * iPercent)/100;
      iFinal = bound(iFinal,10,iValue);      
      
      for i in plItem_Attributes
      {
         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
         iFinal = Send(oItemAtt,@AdjustPrice,#value=iFinal,
                       #iCompound=First(i));
      }
      
      return iFinal;
   }

   GetMaxHits()
   {
      return piHits_init;
   }

   GetHits()
   {
      return piHits;
   }

   SetMaxHits(number = $)
   {
      if number = $
      {  
         return;
      }

      piHits_init = number;

      return;   
   }

   SetHits(number = $)
   {
      if number = $
      {
         return;
      }

      piHits = number;

      return;
   }

   %%% Dynamic Modification Hooks %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   % These messages hook into combat calculations at different locations and
   % allow any equipped item to dynamically modify the respective message it
   % hooks into.
   
   % Hooks into UserAttack and decides whether we can attack or not. Needs to
   % provide the user with a reason why the attack was not executed.
   AttackHook(who=$,what=$,use_weapon=$,stroke_obj=$)
   {
      return TRUE;
   }
   
   % Hooks into GetDamage and can modify the damage bonus factor.
   DamageHook(who=$,what=$,use_weapon=$,stroke_obj=$)
   {
      return 0;
   }

   % Hooks into GetDamageReduction and can modify the damage reduction factor.
   DamageReductionHook(who=$,what=$,damage=0,attacktype=0,spelltype=0)
   {
      return 0;
   }

   % Hooks into GetOffense and can modify offense rating.
   OffenseHook(who=$,what=$,use_weapon=$,stroke_obj=$)
   {
      return 0;
   }

   % Hooks into GetDefense and can modify defense rating.
   DefenseHook(who=$,what=$,use_weapon=$,stroke_obj=$)
   {
      return 0;
   }

   % Hooks into GetSpellPower and can modify spellpower.
   SpellPowerHook(oSpell=$)
   {
      return 0;
   }

   % This is a bit of a special case. Since items may have item and/or object
   % attributes that may contribute to the item's power, we need to run through
   % the list of attributes to check for spellpower modifications. To keep
   % message names consistent, we ask the item for its conditional spellpower
   % bonus with the standard SpellPowerHook before adding the attribute
   % modifiers with this message, which spell.kod points to.
   SpellPowerHookForItems(oSpell=$)
   {
      local oItemAtt, iModifier, i, iNum, oObjectAttribute;

      iModifier = Send(self,@SpellPowerHook,#oSpell=oSpell);
      for i in plItem_Attributes
      {
         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
         iModifier = iModifier + Send(oItemAtt,@SpellPowerHook,#oSpell=oSpell,
            #who=poOwner);
      }
      
      for oObjectAttribute in plObject_attributes
      {
         iModifier = iModifier + Send(oObjectAttribute,@SpellPowerHook,
            #oSpell=oSpell,#who=poOwner);
      }
      
      return iModifier;
   }
   
   % Infrastructure Messages

   NewOwner(what = $)
   {
      local lData;

      % If the person who is supposed to pick up an item picks up 
      % the item, then remove the corpsepointer.
          
      if poOwner <> $ AND Send(self,@HasAttribute,#ItemAtt=IA_CORPSEPOINTER)
      {  
         Send(self,@RemoveAttribute,#ItemAtt=IA_CORPSEPOINTER);
      }      

      if poOwner <> $ AND Send(self,@HasAttribute,#ItemAtt=IA_BONDED)
      {
         lData = Send(self,@GetAttributeData,#ItemAtt=IA_BONDED);
         Send(Send(SYS,@FindSpellByNum,#num=SID_BOND),@BondedItemReport,
              #BondedItem=self,#BondedPlayer=Nth(lData,2),
              #BondedItemOwner=what);
      }      

      if what <> $ 
         AND (IsClass(what,&User)) 
         AND (Send(self,@IsCursed)) 
         AND (NOT Send(what,@PlayerIsImmortal))
      {
         Send(what,@MsgSendUser,#message_rsc=item_try_use_cursed_rsc);
         Post(what,@TryUseItem,#what=self);
      }

      propagate;
   }

   ReqUseSomething(what = $)
   {
      return TRUE;
   }

   NewUsed()
   {
      Send(self,@DoPlayerArt);
      If IsClass(poOwner,&Player)
      {
         Post(poOwner,@RefreshPlayerVisualGear);
      }

      return;
   }

   UserLogoff()
   "Called when we're used by someone, and they logoff."
   {
      return;
   }

   UserLogon()
   "Called when we're used by someone, and they logon."
   {
      return;
   }

   ReqUse()
   "Called when the player tries to use the item"
   {
      local i, oItemAtt, iNum;
          
      %% check to be sure nothing in ItemAtts disallows this
      for i in plItem_Attributes
      {
         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
         if NOT Send(oItemAtt,@ItemReqUse,#oItem=self,#oPlayer=poOwner)
         {
            return FALSE;
         }
      }
      
      return TRUE;
   }

   ReqUnuse()
   "Called when the player tries to unuse the item"
   {
      local i, oItemAtt, iNum;
          
      % Check to be sure nothing in ItemAtts disallows this
      for i in plItem_Attributes
      {
         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
         if NOT Send(oItemAtt,@ItemReqUnuse,#oItem=self,#oPlayer=poOwner)
         {
            return FALSE;
         }
      }
      
      return TRUE;
   }

   NewUnused()
   {
      Send(self,@UndoPlayerArt);

      return;
   }

   ReqNewOwner(what=$)
   {      
      return ((poOwner = $) OR Send(poOwner,@ReqLeaveHold,#what=self));
   }

   ReqLeaveOwner()
   {
      local i, oItemAtt, iNum;

      for i in plItem_Attributes
      {
         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
         if NOT Send(oItemAtt,@ItemReqLeaveOwner,#oItem=self)
         {
            return FALSE;
         }
      }
      
      propagate;
   }

   ReqNewOwnerAttributes(who=$,type = 0)
   "This checks to see if there is anything that prevents a player from "
   "picking up an item due to that item's attributes alone.  Note: these "
   "attributes are responsible for providing error code."
   {
      local i, oItemAtt, iNum;

      % Type 0 is get
      % Type 1 is offer

      for i in plItem_Attributes
      {
         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
         if NOT Send(oItemAtt,@CanGetAffectedItem,#who=who,#lData=i,
                     #oItem=self,#type=type)
         {
            return FALSE;
         }         
      }
      
      return TRUE;
   }
   
   SendAnimation()
   {
      if (piItem_flags & ITEM_PALETTE_MASK) <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION, 1,piItem_flags&ITEM_PALETTE_MASK);
      }

      if piHits > 0 OR viBroken_group = $
      {
         AddPacket(1,ANIMATE_NONE, 2,viGround_group);
      }
      else
      {
         AddPacket(1,ANIMATE_NONE, 2,viBroken_group);
      }
      
      return;
   }

   SendLookAnimation()
   {
      if (piItem_flags & ITEM_PALETTE_MASK) <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION, 1,piItem_flags&ITEM_PALETTE_MASK);
      }

      if piHits > 0 OR viBroken_group = $
      {
         AddPacket(1,ANIMATE_NONE, 2,viInventory_group);
      }
      else
      {
         AddPacket(1,ANIMATE_NONE, 2,viBroken_group);
      }
      
      return;
   }

   SendInventoryAnimation()
   {
      if (piItem_flags & ITEM_PALETTE_MASK) <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION, 1,piItem_flags&ITEM_PALETTE_MASK);
      }
      
      if piHits > 0 OR viBroken_group = $
      {
         AddPacket(1,ANIMATE_NONE, 2,viInventory_group);
      }
      else
      {
         AddPacket(1,ANIMATE_NONE, 2,viBroken_group);
      }
      
      return;
   }

   SendInventoryOverlays()
   {
      AddPacket(1, 0);
      
      return;
   }

   SendOverlayInformation()
   {
      AddPacket(4,Send(self,@GetOverlay));
      AddPacket(1,Send(self,@GetOverlayHotspot));
      Send(self,@SendOverlayAnimation);
      
      return;
   }

   GetNumberOverlays()
   {
      % Most overlay items only offer one overlay.
      %  Some items like weapons and bows may offer two.
      return 1;
   }

   IsCursed()
   "This returns TRUE if a RemoveCurse spell should unuse the item."
   "Since an ItemAtt can curse an item, go through those to check."
   {
      local i, oItemAtt, iNum;
                
      % Check to be sure nothing in ItemAtts disallows this
      for i in plItem_Attributes
      {
         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
         if Send(oItemAtt,@ItemIsCursed,#oItem=self)
         {
            return TRUE;
         }
      }

      return FALSE;
   }

   % Armor and weapon handle this independently.
   DamageGear(damage=0,attacktype=0,spelltype=0)
   {
      return;
   }

   ItemBrokenInBattle()
   {
      local i, oItemAtt, iNum;

      % Remove itematts from us, since we're not gonna use 'em anymore.
      % This also lets cursed items finally remove themselves from us.
      for i in plItem_Attributes
      {
         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
         Send(oItemAtt,@RemoveFromItem,#oItem=self);
      }
   
      Send(poOwner,@SomethingChanged,#what=self);        
      Send(poOwner,@MsgSendUser,#message_rsc=vrItem_broken,
           #parm1=Send(self,@GetName));
      Send(poOwner,@TryUnuseItem,#what=self);
      
      return;
   }

   AdjustsMaxHealth()
   {
      return FALSE;
   }

   AdjustsMaxMana()
   {
      return FALSE;
   }

   IsItemType(type = ITEMTYPE_MISC)
   {
      % Check for misc items (type 0)
      if type = viItem_type            
      {
         return TRUE;
      }               

      return (viItem_type & type);
   }

   DoShatter()
   "Shatters the item.  Include any special functions here."
   {
      Send(self,@Delete);

      return;
   }
   
   Delete()
   {
      Send(self,@ClearAllItemAttributes);
      
      propagate;
   }

   ObjectCorpseFading(corpse=$)
   {
      local lData;
          
      if NOT Send(self,@HasAttribute,#ItemAtt=IA_CORPSEPOINTER)
      {
         return;
      }
          
      lData = Send(self,@GetAttributeData,#ItemAtt=IA_CORPSEPOINTER);

      if lData = $
      {
         return;
      }

      if Nth(lData,3) = corpse
      {
         Send(self,@RemoveAttribute,#ItemAtt=IA_CORPSEPOINTER);
      }
      
      return;
   }

   GetPaletteTranslation()
   {
      return piItem_flags & ITEM_PALETTE_MASK;
   }

   SetPaletteTranslation(translation = $)
   {
      piItem_flags = (piItem_flags & ~ITEM_PALETTE_MASK) | translation;
      
      return;
   }

   CanIdentify()
   {
      local i, oItemAtt, iNum;

      for i in plItem_Attributes
      {
         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
            
         if oItemAtt = $
         {
            Debug("Illegal ItemAtt in list!");

            continue;
         }
         
         if NOT Send(oItemAtt,@ItemCanIdentify,#oItem=self)
         {
            return FALSE;
         }
      }
      
      return TRUE;
   }
   
   CanShatter()
   "Called by the shatter spell.  If this is false, the spell fails."
   { 
      local i, oItemAtt, iNum;
      
      for i in plItem_Attributes
      {
         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
                         
         if oItemAtt = $
         {
            Debug("Illegal ItemAtt in list!");

            continue;
         }
         
         if NOT Send(oItemAtt,@ItemCanShatter,#oItem=self)
         {
            return FALSE;
         }
      }

      return TRUE;  
   }

   CanSwap()
   "Called by the swap spell.  If this is false, the spell fails."
   {  
      local i, oItemAtt, iNum;
      
      for i in plItem_Attributes
      {
         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
                         
         if oItemAtt = $
         {
            Debug("Illegal ItemAtt in list!"); continue;
         }
         
         if NOT Send(oItemAtt,@ItemCanSwap,#oItem=self)
         {
            return FALSE;
         }
      }
      
      return TRUE; 
   }

   CanWeaken()
   "Called by the Brittle spell, among other thing."
   {  
      local i, oItemAtt, iNum;

      for i in plItem_Attributes
      {
         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
            
         if oItemAtt = $
         {
            Debug("Illegal ItemAtt in list!");
            
            continue;
         }
         
         if NOT Send(oItemAtt,@ItemCanWeaken,#oItem=self)
         {
            return FALSE;
         }
      }
      
      return TRUE; 
   }

   CanMend()
   "Called by the Mend spell.  If this returns false, the spell fails."
   "Most things are not mendable."
   {  
      return FALSE; 
   }

   CanEnchant(oSpell = $)
   "Can a particular spell enchantment target this item.  Note that for "
   "artifice and shroud, this is true, but for curse and the three "
   "enchantments, this is false."
   {
      local i, oItemAtt, iSpell, iNum;

      iSpell = Send(oSpell,@GetSpellNum);
      if iSpell = SID_HOLY_WEAPON
         OR iSpell = SID_UNHOLY_WEAPON
         OR iSpell = SID_ENCHANT_WEAPON
         OR iSpell = SID_CURSE_WEAPON
      {
         return FALSE;
      }

      if iSpell = SID_SHROUD
      AND (IsClass(self,&Weapon)
         OR IsClass(self,&Armor))
      {
         for i in plItem_Attributes
         {
            iNum = Send(self,@GetNumFromCompound,#compound=First(i));
            oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
                            
            if oItemAtt = $
            {
               Debug("Illegal ItemAtt in list!");
               
               continue;
            }
            
            if NOT Send(oItemAtt,@ItemCanEnchant,#oItem=self)
            {
               return FALSE;
            }
         }

         return TRUE;
      }

      return FALSE;
   }

   DropOnDeath()
   "Most items are dropped on death.  But, assassin's blades and a few other "
   "things are not."
   {
      local i, oItemAtt, iNum;
      
      % Check ItemAtts to be sure nothing funky is there
      for i in plItem_Attributes
      {
         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
         if NOT Send(oItemAtt,@ItemDropOnDeath)
         {
            return FALSE;
         }
      }

      return TRUE;
   }

   CanBeGivenToNPC()
   "For most things this is TRUE.  However, objects like black daggers cannot "
   "be given to NPCs for any reason."
   {
      local i;
      
      for i in plItem_Attributes
      {
         % KLUDGE: We specifically prevent made items from being given to NPCs.
         %  Should be more general.
         if Send(self,@GetNumFromCompound,#compound=First(i)) = IA_MADE
         {
            return FALSE;
         }
      }
      
      return TRUE;
   }   

   CanBeStoredInVault()
   "Black daggers and tokens, especially, cannot be stored in vaults."
   {
      return TRUE;
   }

   ReqDMDelete()
   "Will this item be deleted by a DM Clear Inventory command?"
   {
      return TRUE;
   }

   % An item can format a text effect for players in the room to see,
   %  whether held by a player or not.  If range is specified,
   %  only players within that range will see the effect.
   % Also, one player can be specified (in except) to treat that player
   %  separately.
   RoomMessage(range = $, except = $, except_rsc = $, message_rsc = $,
               parm1 = $, parm2 = $, parm3 = $, parm4 = $,
               parm5 = $, parm6 = $, parm7 = $, parm8 = $)
   {
      local oRoom, oSource, i, range_squared, oPlayer;

      if range <> $
      {
         range_squared = range * range;
      }

      oSource = self;
      oRoom = poOwner;
      if oRoom = $
      {
         return FALSE;
      }
      
      if isClass(oRoom,&Player)
      {
         oSource = poOwner;
         oRoom = Send(oRoom, @GetOwner);
      }
      
      if oRoom = $ OR NOT isClass(oRoom,&Room)
      {
         return FALSE;
      }

      for i in Send(oRoom,@GetHolderActive)
      {
         oPlayer = Send(oRoom,@HolderExtractObject,#data=i);
         if NOT IsClass(oPlayer,&Player)
         {
            continue;
         }

         if range <> $
            AND Send(oPlayer,@SquaredDistanceTo,#what=oSource) >= range_squared
         {
            continue;
         }

         if oPlayer = except
         {
            if except_rsc = $
            {
               continue;
            }

            % message comes from except_rsc, with parm1 missing.
            Send(oPlayer,@MsgSendUser,#message_rsc=except_rsc,
                 #parm1=parm3,#parm2=parm4,#parm3=parm5,#parm4=parm6,
                 #parm5=parm7,#parm6=parm8);
         }
         else
         {
            Send(oPlayer,@MsgSendUser,#message_rsc=message_rsc,
                 #parm1=parm1,#parm2=parm2,#parm3=parm3,#parm4=parm4,
                 #parm5=parm5,#parm6=parm6,#parm7=parm7,#parm8=parm8);
         }
      }

      return;
   }

   %  Item Attributes, added 4 March 97 by Damion Schubert
   % 
   %  ItemAtts are any special attributes that an item might have.  
   %  Examples include training weapons, poisoned weapons and 
   %  enchanted weapons.  These have been generalized so the same 
   %  ItemAtt may be applied to any item.
   %
   %  The ItemAtt Struct (plItem_attributes) is as follows
   %
   %    plItem_attributes = \
   %       [ [WA_const_name, timer, primary_state, secondary_state],
   %         [WA_const_name2, timer, primary_state, secondary_state],
   %         etc.
   %       ]
   %
   %  WA_const_name : a unique constant name as found in blakston.khd
   %  timer : a timer, most often counting down to the enchantment's
   %    extinction.  However, since Item enchantments may last for days, 
   %    the timer may just count down hours, with an additional (usually 
   %    secondary) state value counting days.  If this timer doesn't exist,
   %    the ItemAtt is permanent.
   %  states : any value that the ItemAtt needs to know.  For example, the
   %    strength of attributes such as the strength of poison or the damage
   %    bonus might be stored. Individual ItemAtt code should be examined to
   %    see what this is.
   %
   %  Note, there are thousands of items in a live server.  As a
   %    result, I've taken actions to ensure that as few list nodes are used as
   %    possible for each ItemAtt, so rather than store blank fields which are 
   %    never used, I make it easy for the individual ItemAtts to decide to 
   %    store what information they deem necessary. 
   %    I check to see if those fields exist when using them, allowing me to
   %    collapse the ItemAtt struct as much as possible.  For example, a 
   %    training attribute struct only has one argument, the ItemAtt ID:
   %
   %    plItem_Attributes = [[WA_TRAINING]];
   %
   %  By comparison, you may have a fiery sword, which is only fiery
   %    for a short time (as determined by a timer).  That list looks
   %    like:
   %
   %    plItem_Attributes = [[WA_ATCKTYPE, DurationTimer, ATCK_FIRE]];
   %
   %  This 'telescoping' saves memory.

   %%% Item Attribute Functions
   
   HasAttribute(ItemAtt = $)
   {
      local i;

      for i in plItem_attributes
      { 
         if Send(self,@GetNumFromCompound,#compound=First(i)) = ItemAtt  
         {
            return TRUE;
         }  
      }
      
      return FALSE;
   }

   HasAnyAttribute()
   {
      if plItem_attributes = $
      {
         return FALSE;
      }

      return TRUE;
   }

   GetAttributeData(ItemAtt = $, index = 1)
   {
      local i, n;

      n = 0;
      for i in plItem_attributes
      { 
         if Send(self,@GetNumFromCompound,#compound=First(i)) = ItemAtt
         {
            n = n + 1;
            if n = index
            {
               return i;
            }
         }  
      }
      
      return $;
   }   

   GetNumFromCompound(compound = $)
   {
      if compound = $
      {
         return $;
      }

      return compound / 100;
   }

   GetIDStatusFromCompound(compound = $)
   {
      if compound = $
      {
         return $;
      }

      % If compound is odd, it is IDed. If even, it is not.

      if (compound mod 2) = 1
      {
         return TRUE;
      }

      return FALSE;
   }

   RevealHiddenAttributes()
   {
      local i, bDone;

      bDone = FALSE;
      for i in plItem_Attributes
      {
         if NOT Send(self,@GetIDStatusFromCompound,#compound=First(i))
         {
            setNth(i,1,(First(i)+1));
            bDone = TRUE;
         }
      }
      
      return bDone;
   }

   AddAttributeSpecifics(litemAtt=$)
   "Don't call this directly!  Call this from itematt.kod!"
   {
      if lItemAtt = $ 
      {
         Debug("lItemAtt = $!  Most likely, lItemAtt called directly instead "
               "of from itematt.kod");
      }

      plItem_attributes = Cons(lItemAtt,plItem_attributes);

      return;
   }

   RemoveAttribute(ItemAtt=$)
   "All this does is calls the itematt.kod version of the same thing. "
   "This function is largely unnecessary, and is here only for convenience."
   {
      local oItemAtt;
      
      if ItemAtt = $
      {
         return;
      }
 
      oItemAtt = Send(SYS,@FindItemAttByNum,#num=ItemAtt);
      
      if oItemAtt = $
      {
         Debug("Illegal data sent to RemoveAttribute");

         return;
      }

      Send(oitemAtt,@RemoveFromItem,#oItem=self);
      
      return;
   }

   RemoveAttributeSpecifics(oItemAtt=$, ItemAtt = 0, index = 1)
   "Don't call this directly!  Call this from itematt.kod!"
   {
      local lData;

      if oItemAtt = $ OR ItemAtt = 0
      {
         Debug("Illegal data sent to RemoveAttributeSpecific");
         
         return;
      }

      lData = Send(self,@GetAttributeData,#ItemAtt=ItemAtt,#index=index);
      if lData = $
      {
         Debug("Can't remove a node that isn't there!"); return;
      }

      % First kill the timer if it has one
      if Send(oItemAtt,@HasTimer,#lData=lData)
      {
            if Nth(lData,2) <> $
      	    {
	             DeleteTimer(Nth(lData,2));
		     SetNth(lData,2,$);
	    }
      }
      % now free the nodes
      plItem_Attributes = DelListElem(plItem_Attributes,lData);
      
      return;
   }

   AttributeTimer(timer=$)
   {
      local i, oItemAtt, iNum;

      if timer = $
      {
         Debug("Timer = $!");
         return;
      }

      for i in plItem_Attributes
      {
         if Length(i) >= 2 AND Nth(i,2) = timer
         {  
            % This is the timer that just expired.
            SetNth(i,2,$); % clear it in the data structure first
            iNum = Send(self,@GetNumFromCompound,#compound=First(i));
            oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
            Send(oItemAtt,@TimerExpired,#oItem=self,#lData=i);
            
            return;
         }
      }
      
      Debug("AttributeTimer didn't find enchantment to get rid of!");
      
      return;
   }

   ClearAllItemAttributes()
   "Most likely called if the Item is deleted."   
   {
      local i, oItemAtt, iNum;

      for i in plItem_Attributes
      {
         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
         if oItemAtt = $
         {
            Debug("Illegal ItemAtt in list!");
            
            continue;
         }
         
         Send(oItemAtt,@RemoveFromItem,#oItem=self);
      }
          
      % All items should have cleared fine.  If not, something went wrong.
      if plItem_Attributes <> $
      {
         Debug("Clearing all Item Attributes failed!");
         plItem_Attributes = $;
      }
          
      return;
   }

   BuildDescName()
   {
      local i, iHigh_index, oHigh_obj, oItemAtt, iPriority, iNum;
      
      if plItem_Attributes = $
      {
         propagate;
      }
      
      iHigh_index = 0;  oHigh_obj = $;
      for i in plItem_Attributes
      {
         if NOT Send(self,@GetIDStatusFromCompound,#compound=First(i))
         {
            % If not identified, keep on marching.
            continue;
         }   

         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
         
         iPriority = Send(oItemAtt,@GetNamePriority);
         if iPriority > iHigh_index
         
         {
            iHigh_index = iPriority;
            oHigh_obj = oItemAtt;
         }
      }

      if oHigh_obj = $
      {
         propagate;
      }

      Send(oHigh_obj,@ItemBuildDescName,#oItem=self);      

      return;
   }

   SetTimer(timer_duration=$)
   {
      local tTimer;
      
      if timer_duration = $
      {
         return $;
      }

      tTimer = CreateTimer(self,@AttributeTimer,timer_duration);

      return tTimer;
   }

   GetHeatDamage()
   "Only things worn at the armor position will be asked this, but "
   "just in case, default is 0."
   {
      return 0;
   }

   GetShirtIcon(who=$)
   {
      if Send(who,@GetGender) = GENDER_MALE
      {
         return vrIcon_male;
      }
      
      return vrIcon_female;
   }

   GetLeftArm(who=$)
   {
      local i;

      if Send(self,@OverrideArmsForGauntlets)
      {
         for i in Send(who,@GetPlayerUsing)
         {
            if Send(i,@OverRideArms)
            {
               return Send(i,@GetOverrideLeftArm,#who=who);
            }
         }
      }
      
      if Send(who,@GetGender) = GENDER_MALE
      {
         return vrLeftarm_male;
      }
      
      return vrLeftarm_female;
   }

   OverrideArmsForGauntlets()
   {
      return FALSE;
   }
   
   OverrideArms()
   {
      return FALSE;
   }
   
   GetOverrideRightArm()
   {
      return $;
   }
   
   GetOverrideLeftArm()
   {
      return $;
   }

   GetRightArm(who=$)
   {
      local i;

      if Send(self,@OverrideArmsForGauntlets)
      {
         for i in Send(who,@GetPlayerUsing)
         {
            if Send(i,@OverRideArms)
            {
               return Send(i,@GetOverrideRightArm,#who=who);
            }
         }
      }

      if Send(who,@GetGender) = GENDER_MALE
      {
         return vrRightarm_male;
      }
      
      return vrRightarm_female;
   }   

   GetNakedLeftArm(who=$)
   {
      local i;

      for i in Send(who,@GetPlayerUsing)
      {
         if Send(i,@OverRideArms)
         {
            return Send(i,@GetOverrideLeftArm,#who=who);
         }
      }

      if Send(who,@GetGender) = GENDER_MALE
      {
         return nakedleftarm_male;
      }

      return nakedleftarm_female;
   }

   GetNakedRightArm(who=$)
   {
      local i;

      for i in Send(who,@GetPlayerUsing)
      {
         if Send(i,@OverRideArms)
         {
            return Send(i,@GetOverrideRightArm,#who=who);
         }
      }

      if Send(who,@GetGender) = GENDER_MALE
      {
         return NakedRightarm_male;
      }

      return NakedRightarm_female;
   }   

   GetLegs(who=$)
   {
      if Send(who,@GetGender) = GENDER_MALE
      {
         return vrLegs_male;
      }
      
      return vrLegs_female;
   }   

   HasSkinTones()
   {
      return FALSE;
   }

   ShowShirt()
   {
      return FALSE;
   }

   ResetSkinColor()
   {
      local iSkin_color, iColor, iXlat;
      
      if not Send(self,@HasSkinTones)
      {
         return;
      }

      iSkin_Color = Send(SYS,@DecodeSecondaryColor,
                         #xlat=Send(self,@GetPaletteTranslation));
      if iSkin_Color <> Send(poOwner,@GetSkinColor)
      {
         iSkin_Color = Send(poOwner,@GetSkinColor);
         iSkin_color = Send(poOwner,@ConvertSkinColorToXLAT,
                            #skin_color=iSkin_color);
         iColor = Send(SYS,@DecodePrimaryColor,
                       #xlat=Send(self,@GetPaletteTranslation));
      
         iXlat = Send(SYS,@EncodeTwoColorXLAT,#color1=iColor,
                      #Color2=iSkin_color);
         Send(self,@SetPaletteTranslation,#translation=iXlat);
      }

      return;
   }

   ResetXLATsToShirt()
   {
      local iSkin_color, iColor, iXlat, iShirt_XLAT;
      
      if not Send(self,@ShowShirt)  { return; }
      iShirt_XLAT = Send(poOwner,@GetCurrentShirtColor);

      if (iShirt_XLAT <> Send(self,@GetPaletteTranslation))
      {
         Send(self,@SetPaletteTranslation,#translation=iShirt_Xlat);
      }
      
      return;
   }

   UndoPlayerArt()
   {
      local oRoom, oShirt;

      if (poOwner <> $)
      {
         if vrIcon_male <> $
         {
            Send(poOwner,@ResetPlayerIcon,#alldone=FALSE);
         }
         
         if vrLeftArm_male <> $
         {
            Send(poOwner,@ResetPlayerArms,#alldone=FALSE);
         }
         
         if  vrLegs_male <> $
         {
            Send(poOwner,@ResetPlayerLegs,#alldone=FALSE);
         }
         
         Post(poOwner,@RefreshPlayerVisualGear);
         
         oRoom = Send(poOwner,@GetOwner);
         if oRoom <> $
         {         
            Post(oRoom,@SomethingChanged,#what=poOwner);
         }
      }
      
      return;
   }

   DoPlayerArt()
   {
      local oRoom;

      % make the player's hands match his sleeves.            
      Send(self,@ResetSkinColor);   

      if Send(self,@ShowShirt)
      {
         Send(self,@ResetXLATsToShirt);
      }

      if vrLeftArm_male <> $
      {
         Send(self,@SetArms,#alldone=FALSE);
      }

      if vrIcon_male <> $
      {
         Send(self,@SetIcon,#alldone=FALSE);
      }

      if  vrLegs_male <> $
      {
         Send(self,@SetLegs,#alldone=FALSE);
      }
      
      oRoom = Send(poOwner,@GetOwner);
      if oRoom <> $
      {         
         Send(oRoom,@SomethingChanged,#what=poOwner);
      }
      
      return;
   }
   
   ItemChangesArms()
   {
      if vrLeftArm_male <> $
      {
         return TRUE;
      }
       
      return FALSE;
   }

   SetNakedArms()
   {
      local iSkin_xlat;
      
      iSkin_Xlat = Send(poOwner,@GetSkinColor);      
      iSkin_Xlat = Send(poOwner,@ConvertSkinColorToXLAT,
                        #skin_color=iSkin_Xlat);
      iSkin_Xlat = Send(SYS,@EncodeTwoColorXLAT,#color1=iSkin_XLAT,
                        #color2=iSkin_XLAT);      
      Send(poOwner,@SetPlayerArms,#what=self,
           #new_left_arm=Send(self,@GetNakedLeftArm,#who=poOwner),
           #new_right_arm=Send(self,@GetNakedRightArm,#who=poOwner),
           #translation=iSkin_Xlat,#alldone=FALSE);
           
      return;
   }

   SetArms()
   {
      Send(poOwner,@SetPlayerArms,#what=self,
           #new_left_arm=Send(self,@GetLeftArm,#who=poOwner),
           #new_right_arm=Send(self,@GetRightArm,#who=poOwner),
           #translation=Send(self,@GetPaletteTranslation),#alldone=FALSE);
           
      return;
   }

   SetIcon()
   {
      Send(poOwner,@SetPlayerIcon,#what=self,
           #new_icon=Send(self,@GetShirtIcon,#who=poOwner),
           #translation=Send(self,@GetPaletteTranslation),#alldone=FALSE);
           
      return;
   }

   SetLegs()
   {
      Send(poOwner,@SetPlayerLegs,#what=self,
           #new_legs=Send(self,@GetLegs,#who=poOwner),
           #translation=Send(self,@GetPaletteTranslation),#alldone=FALSE);
           
      return;
   }

   IsPlural()
   {
      return FALSE;
   }

   GetUnrevealedColor()
   "Returns the item's color before being revealed."
   {
      return viUnrevealedColor;
   }
   
   GetRevealedColor()
   "Returns the item's mystery revealed color."
   {
      return viRevealedColor;
   }
   
   RevealHiddenColor()
   "Shows the item's true color."
   {
      if viRevealedColor <> 0
         AND viUnrevealedColor <> 0
         AND Send(self,@GetPaletteTranslation) = (viUnrevealedColor & ITEM_PALETTE_MASK)
      {
         Send(self,@SetPaletteTranslation,#translation=viRevealedColor);
         return TRUE;
      }
      return FALSE;
   }
  
   GetCurrentResistances()
   {
      local lCurrentResistances, oObjectAttribute;
      
      lCurrentResistances = Send(self,@GetResistanceModifiers);
      
      for oObjectAttribute in plObject_attributes
      {
         lCurrentResistances = Send(oObjectAttribute,@ModifyResistance,#resistance_list=lCurrentResistances);
      }
      
      return lCurrentResistances;
   }

   ModifyResistance(resistance_list=$)
   {
      local oResist, lCurrentResistances;
      
      lCurrentResistances = Send(self,@GetCurrentResistances);
      
      for oResist in lCurrentResistances
      {
         resistance_list = Send(SYS,@AddResistance,#what=Nth(oResist,1),#value=Nth(oResist,2),#resistance_list=resistance_list);
      }
      
      return resistance_list;
   }

   AddRadiusEnchantment(what=$,iPower=0,source=$)
   {
      local i;
      
      for i in plRadiusEnchantments
      {
         if Nth(i,1) = what
            AND Nth(i,2) = iPower
            AND Nth(i,3) = source
         {
            return;
         }
      }

      plRadiusEnchantments = Cons([what,iPower,source],plRadiusEnchantments);
      
      If IsClass(self,&User)
      {
         Send(self,@ShowAddEnchantment,#what=what,#type=2);
         
         If source = self
         {
            Send(self,@ShowAddEnchantment,#what=what,#type=1);
         }
      }
      
      return;
   }

   RemoveRadiusEnchantment(what=$,iPower=0,source=$)
   {
      local i, bFound;

      bFound = FALSE ;
      for i in plRadiusEnchantments
      {
         if Nth(i,1) = what
            AND Nth(i,2) = iPower
            AND Nth(i,3) = source
         {
            If IsClass(self,&User)
            {
               Send(self,@ShowRemoveEnchantment,#what=Nth(i,1),#type=2);

               If source = self
               {
                  Send(self,@ShowRemoveEnchantment,#what=Nth(i,1),#type=1);
               }
            }
         
            plRadiusEnchantments = DelListElem(plRadiusEnchantments,i);
            bFound = TRUE;
         }
      }

      if NOT bFound
      {
         Debug(self,"Tried to remove radius enchantment ",what," but not in list",
               plRadiusEnchantments);
      }

      return;
   }
   
   IsAffectedByRadiusEnchantment(what=$,caster=$,byClass=&RadiusEnchantment)
   "Returns whether or not currently enchanted by <what> radius enchantment."
   {
      local i;
      
      if plRadiusEnchantments = $
      {
         return FALSE;
      }

      if what = $
      {
         for i in plRadiusEnchantments
         {
            if IsClass(Nth(i,1),byClass)
            {
               if caster = $
               {
                  return TRUE;
               }
               else
               {
                  if Nth(i,3) = caster
                  {
                     return TRUE;
                  }
               }
            }
         }
      }
      else
      {
         for i in plRadiusEnchantments
         {
            if Nth(i,1) = what
            {
               if caster = $
               {
                  return TRUE;
               }
               else
               {
                  if Nth(i,3) = caster
                  {
                     return TRUE;
                  }
               }
            }
         }      
      }
      
      return FALSE;
   }
   
   GetMostPowerfulRadiusEnchantmentState(byClass=&RadiusEnchantment)
   {
      local i, oHighest;
   
      oHighest = $;
   
      for i in plRadiusEnchantments
      {
         if IsClass(Nth(i,1), byClass)
         {
            if oHighest = $
            {
               oHighest = i;
            }
            else
            {
               if Nth(i,2) > Nth(oHighest,2)
               {
                  oHighest = i;
               }
            }
         }
      }
      return oHighest;
   }
   
   GetRadiusEnchantments()
   {
      return plRadiusEnchantments;
   }
   
   IsInSameRoom(what = $)
   {
      if Send(self,@GetOwner) <> $
         AND IsClass(Send(self,@GetOwner),&Room)
         AND Send(what,@GetOwner) <> $
         AND IsClass(Send(what,@GetOwner),&Room)
         AND Send(self,@GetOwner) = Send(what,@GetOwner)
      {
         return 1;
      }
         
      return 0;
   }

   SquaredDistanceTo(what = $)
   "Computes squared distance to <what>. Returns $ for any object that is not within a room."
   {
      local iRow, iCol;
      
      If NOT Send(self,@IsInSameRoom,#what=what)
      {
         return $;
      }

      iRow = Send(what,@GetRow);
      iCol = Send(what,@GetCol);

      % Sanity checking
      if iRow = $ OR iCol = $ OR Send(self,@GetRow) = $ OR Send(self,@GetCol) = $
      {
         return $;
      }

      return send(self,@SquaredDistanceToLocation,#row=iRow,#col=iCol);
   }

   SquaredDistanceToLocation(row = $, col = $)
   "Computes squared distance to (row,col)"
   {
      local iRow_diff, iCol_diff;

      iRow_diff = Send(self,@GetRow) - row;
      iCol_diff = Send(self,@GetCol) - col;

      return  (iRow_diff * iRow_diff + iCol_diff * iCol_diff);
   }

   AddMagicFlag()
   {
      if viObject_flags <> (OF_GETTABLE | OF_ITEM_MAGIC)
      {
         viObject_flags = viObject_flags | OF_ITEM_MAGIC;
      }

      if poOwner <> $
         AND IsClass(poOwner,&Player)
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   RemoveMagicFlag()
   {
      local i, iNum, oItemAtt;
      
      for i in plItem_attributes
      {
         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
         
         if Send(oItemAtt,@IsMagicalEffect)
         {
            viObject_flags = viObject_flags | OF_ITEM_MAGIC;
            
            if poOwner <> $
               AND IsClass(poOwner,&Player)
            {
               Send(poOwner,@SomethingChanged,#what=self);
            }

            return;
         }
      }

      viObject_flags = viObject_flags & ~OF_ITEM_MAGIC;

      if poOwner <> $
         AND IsClass(poOwner,&Player)
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
